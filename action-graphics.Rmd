# Graphics {#action-graphics}

```{r, include = FALSE}
source("common.R")
```

We talked briefly about `renderPlot()` in Chapter \@ref(basic-ui); it's a powerful tool for displaying graphics in your app. This chapter will show you how to use it to its full extent, including how to make your plots interactive. You'll also learn two important related functions: `renderCachedPlot()`, which speeds up your app by caching frequently used plots, and `renderImage()`, which allows you to serve images created in other ways.

In this chapter, we'll show a few base graphics, but will focus on ggplot2.

```{r setup}
library(shiny)
library(ggplot2)
```

## Interactivity

One of the coolest things about `plotOutput()` is that it can also be used as an input, allowing you to create interactive graphics. This is a very powerful tool, and has a wide range of applications. Here I'll show the basics, and give you a few pointers about how you might extend for your own purposes.

There are four mouse events that you can respond to on a plot: `click`, `dblClick` (double click), `hover` (fired when the mouse stays in the same place for a little while), and `brush`. To turn these events into Shiny inputs, you supply a string to the corresponding argument, which then creates an input with that name. For example, imagine you wanted to create a plot that responded to click events. You'd set `plotOutput("plot", click = "plot_click")`.

Here's a simple example that displays the location of the mouse click (note that the location is in data coordinates):

```{r}
ui <- basicPage(
  plotOutput("plot", click = "plot_click"),
  verbatimTextOutput("info")
)

server <- function(input, output) {
  output$plot <- renderPlot({
    plot(mtcars$wt, mtcars$mpg)
  }, res = 96)

  output$info <- renderPrint({
    req(input$plot_click)
    x <- round(input$plot_click$x, 2)
    y <- round(input$plot_click$y, 2)
    paste0("[", x, ", ", y, "]")
  })
}
```

(Note the use of `req()`; that makes sure the app doesn't do anything before the first click.)

The following sections describe the events in more details. We'll start with the "point" events, `click`, `dblClick` and `hover`, whose primary data is the `x` and `y` location of the event (in various units). Then we'll discuss the `hover` event, which gives a rectangle defined by its four sides (`xmin`, `xmax`, `ymin`, and `ymax`). I'll give a brief example of using these events to maintain a logical selection vector; we'll come back to the underlying ideas later in Chapter XYZ.

If you're looking for more general interactivity, you might also want to consider the plotly package, as documented in the book *[Interactive web-based data visualization with R, plotly, and shiny](https://plotly-r.com)*, by Carson Sievert.

### Clicking

The point events return a relatively rich data structure. The most important components of the output `x` and `y` components that give the location of the event in data coordinates. But I'm not going to talk about the input, since you'll only need to use it directly in relatively rare situations. Instead, you'll use the `nearPoints()` helper, which finds data points near the event, taking care of a bunch of fiddly details along the way. Here's a simple example of `nearPoints()` in action, showing a table of data about the points near the event:

```{r}
ui <- fluidPage(
  plotOutput("plot", click = clickOpts("click")),
  tableOutput("data")
)
server <- function(input, output, session) {
  output$plot <- renderPlot({
    plot(mtcars$wt, mtcars$mpg)
  }, res = 96)
  
  output$data <- renderTable({
    nearPoints(mtcars, input$click, xvar = "wt", yvar = "mpg")
  })
}
```

Here we give `nearPoints()` four arguments: the data frame the underlies the plot, the input event, and the names of the plotted `x` and `y` variables. If you use ggplot2, you only need to provide the first two arguments since `x_arg` and `y_arg` can be automatically imputed from the plot data structure. For that reason, I'll use ggplot2 throughout the rest of the chapter.

Here's the previous Shiny app reimplemented with ggplot2:

```{r}
ui <- fluidPage(
  plotOutput("plot", click = "plot_click"),
  tableOutput("data")
)
server <- function(input, output, session) {
  output$plot <- renderPlot({
    ggplot(mtcars, aes(wt, mpg)) + geom_point()
  }, res = 96)
  
  output$data <- renderTable({
    nearPoints(mtcars, input$plot_click)
  })
}
```

Another way to use `nearPoints()` is with `allRows = TRUE` and `addDist = TRUE`; that returns the original data frame with two new columns:

-   `dist_` gives the distance between the row and the event (in pixels).
-   `selected_` says whether or not it should be selected (i.e. the logical vector that's returned.

### Other point events

As well as `click`, you can perform the same operations with `hover` and `dblClick`; just change the name of the argument. You can of course use multiple event types on one plot. Just make sure to explain to the user what they can do: one downside of mouse events is that they're not immediately obvious[^1].

If needed, you can get additional control over the events by supplying `clickOpts()`, `dblclickOpts()`, or `hoverOpts()` instead of a string giving the input id. These are rarely needed, so I won't discuss them here; see the documentation for details.

### Brushing

Another way of selecting points on a plot is to use a **brush**, a rectangular selection defined by four edges. Once you've mastered click and `nearPoints()`, using the brush is straighforward: you use the `hover` event and the `brushedPoints()` helper. Here's another simple example that just shows which points have been selected by the brush:

```{r}
ui <- fluidPage(
  plotOutput("plot", brush = "plot_brush"),
  tableOutput("data")
)
server <- function(input, output, session) {
  output$plot <- renderPlot({
    ggplot(mtcars, aes(wt, mpg)) + geom_point()
  }, res = 96)
  
  output$data <- renderTable({
    brushedPoints(mtcars, input$plot_brush)
  })
}
```

If you want to change the colour of the brush, you'll need to use `brushOpts()`. You can also set the `direction` if you want to brush only the `x` or `y` axes. This is useful for (e.g) brushing time series.

### Modifying data

So far we've displayed the results of the interaction in another output. But the true elegance of interactivity comes when you display the changes in the same plot you're interacting with. Unfortunately this requires an advanced reactivity technique that you have yet learned about: `reactiveVal()`. We'll come back to `reactiveVal()` in Chapter XYZ, but I wanted to show it here because it's such a useful technique. You'll probably need to re-read this section after you've read that chapter, but hopefully even without all the theory you'll get a sense of the potential applications.

`reactiveValue()` is similarly to `reactive()` except that you can modify it by supplying an argument when you call it. The following code shows the basic idea:

```{r, eval = FALSE}
val <- reactiveVal(10)
val()
#> [1] 10
val(20)
val()
#> [1] 20
```

One of the challenges of learning `reactiveVal()` is that doesn't work in the console because it must be run in an reactive environment. This is one of the challenges we'll come back to later in the book.

But lets see how we might use it. For example, imagine that you want to visualise the distance between a click and the points on the plot. First we create a reactive value that initialises the distance to a constant (that'll be used before we click anything). Then we use `observeEvent()` to update the reactive value when the mouse is clicked. All up, this looks something like:

```{r}
df <- data.frame(x = rnorm(100), y = rnorm(100))

ui <- fluidPage(
  plotOutput("plot", click = "plot_click")
)
server <- function(input, output, session) {
  dist <- reactiveVal(rep(1, nrow(df)))
  observeEvent(input$plot_click,
    dist(nearPoints(df, input$plot_click, allRows = TRUE, addDist = TRUE)$dist_)  
  )
  
  output$plot <- renderPlot({
    df$dist <- dist()
    ggplot(df, aes(x, y, size = dist)) + 
      geom_point() + 
      scale_size_area(limits = c(0, 1000), max_size = 10, guide = NULL)
  })
}
```

There are two important ggplot2 techniques to note here:

-   I add the distances to the data frame before plotting it. It's good practice to put everything that you're visualising in a single data frame.
-   I set the `limits` to `scale_size_area()` to ensure that sizes are comparable over time. I just did a little interactive experimentation to find the range, but in an exercise you'll work out the exact details.

Here's a more complicated idea. I'm going to allow the user to click points to add or remove them from a model fit. I use `nearPoint()` to find which points are near the click, then `ifelse()` to toggle their values: if they were previously excluded they'll be included; if they were previously included, they'll be excluded.

```{r}
ui <- fluidPage(
  plotOutput("plot", click = clickOpts("click")),
  tableOutput("data")
)
server <- function(input, output, session) {
  selected <- reactiveVal(rep(TRUE, nrow(mtcars)))
  
  output$plot <- renderPlot({
    mtcars$sel <- selected()
    ggplot(mtcars, aes(wt, mpg)) + 
      geom_point(aes(colour = sel)) +
      scale_colour_discrete(limits = c("TRUE", "FALSE"))
  }, res = 96)
  
  observeEvent(input$click, {
    clicked <- nearPoints(mtcars, input$click, allRows = TRUE)$selected_
    selected(ifelse(clicked, !selected(), selected()))
  })
}
```

Again, I set the limits of the scale to ensure that the legend (and colours) don't change after the first click.

### Data flow

It's important to understand the basic data flow in interactive plots in order to understand their limitations.

1.  Javascript captures mouse event.
2.  Shiny sends the javascript mouse event back to R, invalidating the input.
3.  Downstream reactive consumers are recomputed.
4.  `plotOutput()` generates a new PNG and sends it to the browser.

For local apps, the bottleneck tends to be the time taken to draw the plot. Depending on how complex the plot is, this may take a signficant fraction of a second. But for hosted apps, you also have to take into account the time needed to transmit the event from the browser to the R, and then the rendered plot back from R to the browser.

In general, this means that it's not possible to create Shiny apps where action and response is percieved as instanteous (i.e. the plot updates simultaneously with your action). If you need this level of speed, you'll need to perform more computation in javascript.

### Dynamic height and width

Before we move on to plot caching, there's one other handy trick I wanted to mention: you can make the size of a plot reactive, so it changes size based on the user's interaction with other controls. To do this, you supply zero-argument functions that return the size in pixels to `height` and `width`. These are evaluated in a reactive environment so that you can make the size of your plot dynamic.

The following app illustrates the basic idea. It provides two slides that directly control the size of the plot.

```{r}
ui <- fluidPage(
  sliderInput("height", "height", min = 100, max = 500, value = 250),
  sliderInput("width", "width", min = 100, max = 500, value = 250),
  sliderInput("n", "n", min = 10, max = 100, value = 25),
  plotOutput("plot", width = 250, height = 250)
)
server <- function(input, output, session) {
  output$plot <- renderPlot(
    width = function() input$width,
    height = function() input$height,
    res = 96,
    {
      plot(rnorm(input$n), rnorm(input$n))
    }
  )
}
```

Note that the plot is re-drawn, but the code is not rerun (i.e. the random values say the same). This is the same behaviour as when you resize a Shiny app that contains a plot with a dynamic height/width (e.g. the default width of 100%).

In real cases, you'd use more complicated expressions in the `width` and `height` functions. For example, if you're using a faceted plot in ggplot2, you might use it to increase the size of the plot to keep the individual facet sizes roughly the same (unfortunately there's no easy way to keep them exactly the same because it's currently not possible to find out the size of the fixed elements around the borders of the plot.)

## `renderCachedPlot()`

Really useful if a plot is seen by multiple users,

<https://shiny.rstudio.com/articles/plot-caching.html>

Mostly a matter of changing `renderPlot()` to `renderCachedPlot()`. But you also need to supply a `cacheKeyExpr`. This is some code that returns an object that basically represents the "state" of the plot; whenever that value changes, the plot will be recomputed.

BASIC EXAMPLE

### Cache key

Best to keep it as simple as possible - should be a list of vectors.

-   Input parameters.
-   Dataset reactive. Avoid using very large datasets as a cache key - it will take some time
-   Timestamp. `proc.time()[[3]] %/% 3600`

Also includes id, and plot size. Also implicitly depends on the current user.

### Sizing policy

Normally plots are rendered to the exact size needed. But that's not very useful for caching: if everyone has a slightly different sized plot, then the cache will never be used. `renderCachePlot()` resolves this problem by only caching plots with a fixed sizes and then resizing as needed.

It uses an exponential rounding strategy determined by the `sizingPolicy` argument. It's unlikely that you'll need to tweak this, but if you do, see the `sizeGrowthRatio()` for details.

Another option worth considering is setting the plots to a fixed size by setting the `width` argument to `plotOutput` to a fixed unit like `"400px"` (the default `height` is already fixed). That will give you the best cache performance because every plot will have the same size.

### Scoping

By default, the plot cache is stored in memory, and shared across all users of the app. If needed, you can override these defaults with:

-   `cache = "session"`: the cache lifetime will tied to a single user. It will be created when the session starts (i.e. when someone first visits you app), and deleted when the session ends.

-   `cache = diskCache(...)`: shares across multiple users, multiple\
    processes, and app-restarts. Beware that restarting the app will no longer clear the cache, so if you change the plotting code, you'll also need to manually reset the cache by deleting the directory.

It's also possible to store in a database, or right your own backend. See <https://shiny.rstudio.com/articles/plot-caching.html#can-i-write-my-own-caching-backend> for more details.

The default memory cache size of 10 MB can hold plenty of plots -- a cached plot object is typically between 50 and 250 kB. You can override with `shinyOptions(cache = memoryCache(size = 20e6))`.

## Images

If you need to display images that you already have saved on disk. These might come from an external source (maybe a directory of photographs), or perhaps you've generated them with another package (e.g. a 3d scene with`rgl::rgl.snapshot()`).

<https://shiny.rstudio.com/articles/images.html>

Unlike `renderPlot()`, `renderImage()` must return a list:

-   `src`: (local) path to the image file.

-   `contentType` entry specifying the MIME type of the image. If one is not provided, will try to detect the type from the file extension. You should only need to set this if you're generating images without file extensions, which generally you won't do.

-   Other components like `width`, `height`

-   `class`, `alt` will be added as attributes to the `<img>` tag.

### Static images

Sample app shows directory full of files.

`www/images`: another option is to put images in the `www/` directory. This is somewhat more efficient as it allows the browser to use caching automatically.

`?shiny::addResourcePath`

> Static files under the www/ directory are automatically made available under a request path that begins with /.

Then use `img()` + `renderUI()` to generate img tags.

### Dynamic images

In most cases, you're better off figuring out how to use `renderPlot()` because it takes care of so many details for you, it's easily cached, and the vast majority of R packages that generate images already provided some way to .

-   Note the `deleteFile` argument. Set it to `TRUE` if you're rendering the image live, and it should be deleted after its been sent to the user. `outfile <- tempfile(fileext = '.png')`

-   You can detect the size of the plot in the browserwith `session$clientData$output_myImage_width` and `session$clientData$output_myImage_height`. (This works for all outputs, but isn't usually needed. ) Also `session$clientData$pixelratio`.

## Exercises

1.  Make a plot with click handle that shows all the data returned in the input.

2.  Make a plot with click, dblclick, hover, and brush output handlers and nicely display the current selection in the sidebar. Plot the plot in the main panel.

3.  Compute the limits of the distance scale using the size of the plot.

```{r}
output_size <- function(id) {
  reactive(c(
    session$clientData[[paste0("output_", id, "_width")]],
    session$clientData[[paste0("output_", id, "_height")]]
  ))
}
```

[^1]: As a general rule, adding explanatory text suggests that your interface is too complex, so is best avoided, where possible. This is the key idea behind "affordances", the idea that an object should suggest naturally how to interact with it as introduced by Don Norman in the *"Design of Everyday Things"*.
