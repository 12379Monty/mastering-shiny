# Basic reactivity {#basic-reactivity}

```{r, include = FALSE}
source("common.R")
```

## Introduction

In the the last chapter, we talked about creating the user interfaces. Now we'll move on to discuss the server side of Shiny, where you use R code at runtime to make your user interface come to life!

In Shiny, you express your server logic using reactive programming. Reactive programming is an elegant and powerful programming paradigm, but it can be disorienting at first because it's a very different paradigm to writing a script. The key idea of reactive programming is to specify a graph of dependencies so that when an input changes, all outputs are automatically updated. This makes the flow of an app considerably simpler, but it takes a while to get your head around how it all fits together.

This chapter will provide a gentle walkthrough of reactive programming, introducing some of the most basic reactive constructs you'll use in your Shiny apps. We'll start with a survey of the server function, discussing in more detail how the `input` and `output` arguments work. Next we'll review the simplest form of reactivity (where inputs are directly connected to outputs), and then discuss how reactive expressions allow you to eliminate duplicated work. We'll finish by reviewing some common roadblocks encountered by newer shiny users.

```{r setup}
library(shiny)
```

## The server function

As you've seen, the guts of every Shiny app looks like this:

```{r, eval = FALSE}
library(shiny)

ui <- fluidPage(
  # Front-end interface
)

server <- function(input, output, session) {
  # Back-end logic
}

shinyApp(ui, server)
```

The previous chapter cover the basics of the front-end, the `ui` object that contains the HTML that is presented to every user of your app. In this chapter, we'll focus on the backend, which is more complex. Inside of a single static object, the backend is a function, `server()`. You'll never call `server()` yourself; rather, Shiny invokes it whenever a new session begins. 

To understand why shiny has a server function, you need to first understand the idea of browser __session__, which captures the state of one live instance of a shiny app. A session begins each time the Shiny app is loaded in a browser, either by different people, or by the same person opening multiple tabs.

The server function is called once for each browser session, creating a private scope for that particular session, encapsulating the unique state. Every variable created inside the server function is only accessible to a single session. This ensures that when user A moves a slider, outputs update only for user A, not user B. Almost of the reactive programming you'll do in Shiny will be inside the server function so that each user gets a independent app[^exceptions]. 

[^exceptions]: The primary exception is where there's some work that can shared across multiple users. For example, all users might be looking at the same large csv file, so you might as well load it once and share it between users. We'll come back to that idea in Chapter XYZ.

Server functions take three parameters: `input`, `output`, and `session`[^session-optional]. You'll never create these objects yourself; instead, they're created by Shiny when the session begins. Each combination of the three arguments connects back to a specific session, and you use those objects to communicate back and forth with the browser. For the moment, we'll focus on `input` and `output`, and leave `session` for later chapters.

[^session-optional]: For legacy reasons, `session` is optional, but you should always include it.

### Input {#input}

The `input` argument is a list-like object that contains all the input data sent from the browser, named according to the input ID. For example, if your UI contains a numeric input control with an input ID of `count`, like so:

```{r}
ui <- fluidPage(
  numericInput("count", label = "Number of values", value = 100)
)
```

Then you can access the value of that input with `input$count`. It will initially contain the value `100`, and it will be automatically updated as the user changes the value in the browser.

Unlike a typical list, `input` objects are read-only. If you attempt to modify an input inside the server function, you'll get an error:

```{r, eval = FALSE}
server <- function(input, output, session) {
  input$count <- 10  
}

shinyApp(ui, server)
#> Error: Attempted to assign value to a read-only reactivevalues object
```

This error occurs because `input` reflects what's happening in the browser, and the browser is the "single source of truth". If you could modify the value in R, you could introduce inconsistencies where the input slider said one thing in the browser, and `input$count` said something different in R. That would make programming challenging!

It is possible, however, to change the value in the browser using `updateNumericInput()`, and then `input$count` will update accordingly. We'll come back to that idea in Chapter XYZ, where we discuss dynamic user interfaces.

One more important thing about `input`: it's selective about who is allowed to read it and you must be in a __reactive context__ to see its value. We'll come back to that idea very shortly, but it's a fundamentally important constraint that allows outputs to automatically update when an input changes. You can see the problem with this server function:

```{r, eval = FALSE}
server <- function(input, output, session) {
  message("The value of input$count is ", input$count)
}

shinyApp(ui, server)
#> Error: Operation not allowed without an active reactive context. 
#> (You tried to do something that can only be done from inside 
#> a reactive expression or observer.)
```

### Output {#output}

The `output` argument is a list-like object that allows you to send data to the browser, named according to the output ID. The various `*Output` UI functions---`plotOutput()`, `tableOutput()`, `textOutput()`, and friends---merely insert empty boxes, or placeholders, into your UI. The `output` object allows you to populate these these empty boxes.

You always use the `output` object in concert with a `render` function, as in the following simple example: 

```{r}
ui <- fluidPage(
  textOutput("greeting")
)

server <- function(input, output, session) {
  output$greeting <- renderText({
    "Hello human!"
  })
}
```

The render function does two things:

* It sets up a reactive context that automatically tracks what inputs 
  you use.
  
* It converts the output of your R code into HTML suitable for display
  in the output control.

(Note that the ID is quoted in the UI, but not in the server.)

Like the `input`, the `output` is picky about how you use it. If you forget the `render` function you'll get an error:

```{r, eval = FALSE}
server <- function(input, output, session) {
  output$greeting <- "Hello human"
}
shinyApp(ui, server)
#> Error: Unexpected character output for greeting
```

And if you attempt to read from an output you'll get an error:

```{r, eval = FALSE}
server <- function(input, output, session) {
  message("The greeting is ", output$greeting)
}
shinyApp(ui, server)
#> Error: Reading objects from shinyoutput object not allowed.
```

You must always write to an output with a render function.


## Reactive programming

An app is going to be pretty boring if it only has inputs or only has outputs. The real magic of Shiny happens when you have an app with both. Let's look at a simple example:

```{r}
ui <- fluidPage(
  textInput("name", "What's your name?"),
  textOutput("greeting")
)

server <- function(input, output, session) {
  output$greeting <- renderText({
    paste0("Hello ", input$name, "!")
  })
}
```

It's hard to show exactly how this works in a book, but if you run the app, and type in the name box, you'll notice that the greeting updates automatically as you type[^debounce]:

```{r, echo = FALSE, out.width = "25%", fig.show="hold"}
app <- testApp(ui, server)
app_screenshot(app, "basic-reactivity/connection-1", width = 200)
app$setInputs(name = "J")
app_screenshot(app, "basic-reactivity/connection-2", width = 200)
app$setInputs(name = "Jo")
app_screenshot(app, "basic-reactivity/connection-3", width = 200)
app$setInputs(name = "Joe")
app_screenshot(app, "basic-reactivity/connection-4", width = 200)
```

[^debounce]: If you're running the live app, notice that you have to type fairly slowly for the output to update one letter at a time. That's because shiny uses a technique called __debouncing__, which means that it waits for XYZ ms before sending an update. That reduces the amount of needless work that Shiny needs to do, without appreciably reducing the response time of the app.

This is the big idea in Shiny: you don't need to specify when the output code is run because Shiny automatically figures it out for you. How does it work? What exactly is going on in the body of the function? Let's look at the code inside the server function in more detail:

```{r, eval = FALSE}
output$greeting <- renderText({
  paste0("Hello ", input$name, "!")
})
```

It's easy to read this as "paste together 'hello' and the user's name, then send it to `output$greeting`". But this mental model is wrong, in a subtle, but important way. Think about it: you only issue the instruction once, but Shiny perform the action every time we update `input$name`. There must be something more going on.

This app works because the code doesn't _tell_ Shiny to create the string and send it to the browser, but instead, it informs Shiny _how it could_ create the string if it needs to. It's up to Shiny when (and even if!) the code should be run; it might be run as soon as the app launches, it might be quite a bit later, it might be many times, or it might never be run. This isn't to imply that Shiny is capricious, only that it's Shiny's responsibility, not yours, to decide when render logic is actually executed. In short, you don't give Shiny commands, you give Shiny recipes.

### Imperative and declarative programming

This is the key difference between two important styles of programming:

* In __imperative__ programming, you issue a specific command and it's 
  carried out immediately. This is the style of programming you're used to
  in your analysis scripts: you command R to load your data, manipulate it,
  visualise it, and save the results to disk.
  
* In __declarative__ programming, you express higher-level goals or
  describe important constraints, and rely on someone else to decide how
  and/or when to translate that into action. This is the style of 
  programming you use in Shiny.

Imperative code says: "Make me a sandwich". Declarative code says: "Ensure there is a sandwich in the refrigerator whenever I open it." (Sorry, sometimes Declarative can be a passive-aggressive jerk.)

Most of the time, declarative programming feels tremendously freeing: you describe your overall goals, and the software figures out how to achieve them without further intervention. The downside is that occasional time where you know exactly what you want, but you can't figure out how to frame them in a way that the declarative system understands. (If you've ever struggled with getting a ggplot2 legend to look exactly the way you want, you've encountered this problem). The goal of this chapter, and the later chapter that go into even more detail, is to decrease that feeling as much as possible! Generally, that involves building up a better mental model of how Shiny works, so you can translate what you want into a framing that Shiny understands.

One of the strengths of declarative programming in Shiny is it that it allows Shiny to be extremely lazy. It only ever does the minimal amount of work needed to update the output controls that you can currently see[^seeing]. This, however, comes at a cost that you should be aware of. Can you spot what's wrong with this minor variation of the server function used above?

[^seeing]: Yes, shiny doesn't update the output if you can't see it in your browser! Shiny is so lazy that it doesn't do the work unless you can actually see the results.

```{r}
server <- function(input, output, session) {
  output$greetnig <- renderText({
    paste0("Hello ", input$name, "!")
  })
}
```

If you look closely, you'll notice that I've written `greetnig` instead of `greeting`. This will not generate an error in Shiny, but it won't do what you want. Because `greetnig` output never exists, the code inside `renderText()` will never be run. If you're working on a shiny app, and you just can't figure out why your code never gets run, make sure that your UI and server functions are using the same names.

### The reactive graph

In most R code, you can understand the order of execution by reading the code from top to bottom. That doesn't work in Shiny, because code is run based on when needed. Instead, it's helpful to look at the __reactive graph__, which describes how inputs and outputs are connected.  The reactive graph for the app above is very simple:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/graph-1b.png", dpi = 300)
```

This graph tells you that whenever `name` is changed, `greeting` will be automatically updated[^simple-model]. Note the graphical conventions we used for the inputs and outputs. The `name` input naturally fits into the `greeting` output. We could draw them closely packed togther, as below, to emphasise the way that they fit together. We won't normally do that, however, since it only works for the simplest of apps.

[^simple-model]: This is somewhat of a simplification as the arrows are in some sense bidirectional. Changing `name` invalidates `greeting`, but `greeting` won't actually be recomputed until it's needed. We'll come back to the full details in Chapter \@ref(reactivity-mental-model): 

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/graph-1a.png", dpi = 300)
```

### Reactive expressions

As you saw in Chapter \@ref(basic-app), reactive expressions allow you to extract out repeated computation. They are extremely important for creating efficient shiny apps because they are only updated when their inputs change. This means that you can use them to encapsulate expensive operations so that they are only re-computed the minimal number of times. This is the same basic idea as tools like `make`, which help you define the dependencies between bigger components of your workflow.

There's not much point in using one for this simple app, but I will, just to show you what the new reactive graph looks like:

```{r}
server <- function(input, output, session) {
  text <- reactive(paste0("Hello ", input$name, "!"))
  output$greeting <- renderText(text())
}
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/graph-2b.png", dpi = 300)
```

Reactive expressions take inputs and produce outputs so they have a shape that combines features of inputs and outputs. Again, you can remember what the shapes mean by packing them together.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/graph-2a.png", dpi = 300)
```

We'll see shortly that reactive expressions are also a powerful tool for simplifying the reactive graph.

In our experience, as your app gets more complicated, it's often useful to make a quick high-level sketch of the reactive graph. Later on, in Chapter XYZ, you'll learn about Shiny's reactlog which will draw the graph for you, and animate how it changes as you run the app.

### Execution order

Note that the order of the code in the server function does not affect the graph. In this simple example, we could flip the order of the two lines:

```{r}
server <- function(input, output, session) {
  output$greeting <- renderText(text())
  text <- reactive(paste0("Hello ", input$name, "!"))
}
```

This app behaves identically to the previous app, but it's confusing for humans to understand because the output refers to a reactive expression that's created later in the code. Don't do this! Instead, make sure that reactive expressions and outputs only refer to things defined early in the app, not later. This will make your code easier to understand.

The order in which reactive code is run is determined only by the reactive graph, not by the layout in the server function.

### Observers
 
So far, we've focussed on what's happening inside the app. But sometimes you need to reach outside of the app and cause side-effects to happen elsewhere in the world. This includes things like saving a file to disk, sending data to a web API, updating a database, or printing to screen.

These don't affect your app, so you can't use `renderText()`, and you can't put them directly inside your server function, you'll get an error about attempting to access a reactive value outside of a reactive context (and even if you didn't, it would only be run once.) 

To solve this problem Shiny provides `observeEvent()`. `observeEvent()` has two important arguments: `eventExpr()` and `handlerExpr()`. The first argument defines the when, and the second argument defines the what. The place you'll use `observeEvent()` most often in your early days of shiny app is to help you debug:

```{r}
server <- function(input, output, session) {
  text <- reactive(paste0("Hello ", input$name, "!"))
  
  output$greeting <- renderText(text())
  observeEvent(
    input$name, message("Greeting performed"),
    label = "message"
  )
}
```

Note that I used the optional `label` argument here. This doesn't change the behaviour of the observer, it just sets a label that will appear in diagrams.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/graph-3.png", dpi = 300)
```

## Case study: simulating data

Let's put all these ideas together and explore a more complex app. The goal of this app is to generate random data from two normal distributions, display the data with a histogram, and perform a t-test. This is what the UI looks like:

```{r}
ui <- fixedPage(
  fluidRow(
    column(4, 
      "Distribution 1",
      numericInput("n_1", label = "n", value = 1000, min = 1),
      numericInput("mean_1", label = "µ", value = 0, step = 0.1),
      numericInput("sd_1", label = "σ", value = 0.5, min = 0.1, step = 0.1)
    ),
    column(4, 
      "Distribution 2",
      numericInput("n_2", label = "n", value = 1000, min = 1),
      numericInput("mean_2", label = "µ", value = 0, step = 0.1),
      numericInput("sd_2", label = "σ", value = 0.5, min = 0.1, step = 0.1)
    ),
    column(4,
      "Histogram",
      numericInput("binwidth", label = "Bin width", value = 0.1, min = 0.001),
      sliderInput("range", label = "range", value = c(-3, 3), min = -5, max = 5)
    )
  ),
  fluidRow(
    column(9, plotOutput("hist")),
    column(3, verbatimTextOutput("ttest"))
  )
)
```
```{r, echo = FALSE, out.width = NULL}
ui_screenshot(ui, "basic-reactivity/case-study-1", width = 800, height = 300)
```

You've seen all these components before, we've just used more of them in a single app than in any previous example. Similarly, the server function doesn't introduce any new ideas:

```{r}
server <- function(input, output, session) {
  library(ggplot2)

    output$hist <- renderPlot({
    x1 <- rnorm(input$n_1, input$mean_1, input$sd_1)
    x2 <- rnorm(input$n_2, input$mean_2, input$sd_2)
    
    df <- data.frame(
      x = c(x1, x2), 
      g = c(rep("x1", length(x1)), rep("x2", length(x2)))
    )
    
    ggplot(df, aes(x, fill = g)) + 
      geom_histogram(binwidth = input$binwidth) + 
      coord_cartesian(xlim = input$range)
  })
  
  output$ttest <- renderText({
    x1 <- rnorm(input$n_1, input$mean_1, input$sd_1)
    x2 <- rnorm(input$n_2, input$mean_2, input$sd_2)
    
    test <- t.test(x1, x2)
    sprintf("p value: %0.3f\n[%0.2f, %0.2f]", 
      test$p.value, test$conf.int[1], test$conf.int[2]
    )
  })
}
```

Before you continue, I recommend openning this app and trying it out: <https://hadley.shinyapps.io/basic-reactivity-cs/>

```{r, eval = FALSE}
deployApp(ui, server, name = "basic-reactivity-cs", deps = "ggplot2")
```

### Outputs are atomic

Shiny is smart enough to run code for an output when that only output needs to be updated. It's not smart enough, however, to only selectively run pieces of code. For example, take this snippet from the example above:

```{r, eval = FALSE}
x1 <- rnorm(input$n_1, input$mean_1, input$sd_1)
x2 <- rnorm(input$n_2, input$mean_2, input$sd_2)

test <- t.test(x1, x2)
```

As a human looking at this code, you can tell that we only need to update `x1` when `n_1`, `mean_1`, or `sd_1` changes, and similarly for `x2`. Shiny, however, only looks at the output as a whole, so it will update both `x1` and `x2` every time one of `n_1`, `mean_1`, `sd_1`, `n_2`, `mean_2`, or `sd_2` changes. 

The reactive graph reinforces this understanding because it only shows inputs and outputs, which is the level of analysis that Shiny operates at. This leads to the following reactive graph:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/case-study-1.png", dpi = 300)
```

You'll notice that the graph is quite dense: almost every input is connected directly to every output. This creates two problems:

* The app is hard to understand because there are so many connections. There are
  no pieces of the app that you can pull apart and analyse in isolation.
  
* The app is inefficient because it does more work than necessary. Currently, 
  if you change the breaks of the plot, the data is recalculated, or if you 
  change the value of `n_1`, `x2` is updated. 
  
There's one other major flaw in the app: the histogram and t-test use independent simulations. This is rather misleading, as you expect them to be using the same underlying data. Fortunately we can fix all these problems by using reactive expressions to pull out repeated computation.

### Using reactive expressions

In the server function below we refactor the existing code to pull out the repeated code into two new reactive expressions `x1` and `x2`. Inside server function, reactive expressions often play the same role that functions do in ordinary analysis code: they are tools to reduce duplication.

```{r}
server <- function(input, output, session) {
  x1 <- reactive(rnorm(input$n_1, input$mean_1, input$sd_1))
  x2 <- reactive(rnorm(input$n_2, input$mean_2, input$sd_2))
  
  output$hist <- renderPlot({
    df <- data.frame(
      x = c(x1(), x2()), 
      g = c(rep("x1", length(x1())), rep("x2", length(x2())))
    )
    
    ggplot(df, aes(x, fill = g)) + 
      geom_histogram(binwidth = input$binwidth) + 
      coord_cartesian(xlim = input$range)
  })
  
  output$ttest <- renderText({
    test <- t.test(x1(), x2())
    sprintf(
      "p value: %0.3f\n[%0.2f, %0.2f]", 
      test$p.value, test$conf.int[1], test$conf.int[2]
    )
  })
}
```

This transformation yields a substantially simpler graph:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/case-study-2.png", dpi = 300)
```

This simpler graph makes it easier to understand the app because you can understand connected components in isolation; the values of the distribution parameters only affect the app via `x1` and `x2`.

### Reactive roadblocks {#reactive-roadblocks}

When you first start working with reactive code, you'll be tempted to draw on your existing tools for reducing duplication in code, creating new variables and writing functions. Unfortunately neither of these techniques work when attempting to reduce duplication in reactive expressions.

If you try and use a variable:

```{r, eval = FALSE}
x1 <- rnorm(input$n_1, input$mean_1, input$sd_1)
x2 <- rnorm(input$n_2, input$mean_2, input$sd_2)

output$ttest <- renderText({
  test <- t.test(x1, x2)
  ...
})
```

you'll get an error because you're attempting to access input values outside of a reactive context. Even if that did work, `x1` and `x2` will only be computed once, when the function runs.

If you try and use a function, it works:

```{r, eval = FALSE}
x1 <- function() rnorm(input$n_1, input$mean_1, input$sd_1)
x2 <- function() rnorm(input$n_2, input$mean_2, input$sd_2)

output$ttest <- renderText({
  test <- t.test(x1(), x2())
  ...
})
```

But it has the same problem as the original code: any input will cause all outputs to be recomputed, and the t-test and the histogram will be run on separate samples.

In brief: while variables calculate the value only once (not often enough), and functions calculate the value every time they're called (too often), reactive expressions calculate the value only when it might have changed (just right!).

You might be familiar with the rule of three from programming: whenever you copy and paste something three times, you should turn it into a function. This is important because it reduces the amount of duplication of in your code, which makes it easier to understand and easier to update as your requirements change. 

In Shiny, however, I think you should adopt the rule of one: whenever you copy and paste something _once_, you should consider extracting out the repeated code into a reactive expression. The rule is stricter for Shiny, because reactive expressions don't just make it easier for humans to understand the code, it also improves Shiny's ability to efficiently rerun code, and perform the minimal amount of work to update the outputs when an input changes. Later on, we'll see how to use shiny modules to extract out repeated code across multiple apps.

## Controlling timing of evaluation

We'll come back to these problems, and the code that makes them tick, later.

### Waiting longer

Imagine we change the default value of `n` to 1 million. This gives us a much more accurate simulation, but the plot and t.test take much longer to run. As soon as the computation takes longer than 50ms it's worth re-thinking the design of your app. Otherwise you'll end up with a bunch of work cued up, that the user actually doesn't care about.

There are two ways we could slow down the number of computations that Shiny performs. Firstly, we could use `debounce()` to reduce the number of events. The below code waits for 250 ms of no activity before recalculating. This means that nothing will happen while the user is rapidly modifying the controls, but will only recompute once they have paused.

```{r, eval = FALSE}
x1 <- eventReactive(
  debounce(list(input$n_1, input$mean_1, input$sd_1), 250), 
  rnorm(input$n_1, input$mean_1, input$sd_1)
)
```

Another approach would be to require the user to click a button when they want to recompute. The idea is very similar: we use `eventReactive()` to split apart the trigger from the result.

```{r, eval = FALSE}
x1 <- eventReactive(
  input$simulate, 
  rnorm(input$n_1, input$mean_1, input$sd_1)
)
```

### Timed invalidation

The flip side is that sometimes you need to update the app when something outside the app has changed. i.e. you need to invalid more often that the reactivity graph would otherwise suggest. You could imagine wanting to make our simulation app emphasise that the underlying data is random, and constantly update the plot.

```{r}
timer <- reactiveTimer(250)
x1 <- reactive({
  timer()
  rnorm(input$n_1, input$mean_1, input$sd_1)
})
x2 <- reactive({
  timer()
  rnorm(input$n_2, input$mean_2, input$sd_2)
})
```

Later on you'll learn about tools like `reactiveFileReader()`
