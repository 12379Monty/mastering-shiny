# Basic reactivity {#basic-reactivity}

```{r, include = FALSE}
source("common.R")
```

## Introduction

In the the last chapter, we talked about creating the user interfaces. Now we'll move on to discuss the server side of Shiny, where you use R code at runtime to make your user interface come to life!

In Shiny, you express your server logic using reactive programming. Reactive programming is an elegant and powerful programming paradigm, but it can be disorienting at first because it's a very different paradigm to writing a script. The key idea of reactive programming is to specify a graph of dependencies so that when an input changes, all outputs are automatically updated. This makes the flow of an app considerably simpler, but it takes a while to get your head around how it all fits together.

This chapter will provide a gentle walkthrough of reactive programming, introducing some of the most basic reactive constructs you'll use in your Shiny apps. We'll start with a survey of the server function, discussing in more detail how the `input` and `output` arguments work. Next we'll review the simplest form of reactivity (where inputs are directly connected to outputs), and then discuss how reactive expressions allow you to eliminate duplicated work. We'll finish by reviewing some common roadblocks encountered by newer shiny users.

```{r setup}
library(shiny)
```

## The server function

As you've seen, the guts of every Shiny app looks like this:

```{r, eval = FALSE}
library(shiny)

ui <- fluidPage(
  # Front-end interface
)

server <- function(input, output, session) {
  # Back-end logic
}

shinyApp(ui, server)
```

The previous chapter cover the basics of the front-end, the `ui` object that contains the HTML that is presented to every user of your app. In this chapter, we'll focus on the backend, which is more complex. Inside of a single static object, the backend is a function, `server()`. You'll never call `server()` yourself; rather, Shiny invokes it whenever a new session begins. 

To understand why shiny has a server function, you need to first understand the idea of browser __session__, which captures the state of one live instance of a shiny app. A session begins each time the Shiny app is loaded in a browser, either by different people, or by the same person opening multiple tabs.

The server function is called once for each browser session, creating a private scope for that particular session, encapsulating the unique state. Every variable created inside the server function is only accessible to a single session. This ensures that when user A moves a slider, outputs update only for user A, not user B. Almost of the reactive programming you'll do in Shiny will be inside the server function so that each user gets a independent app[^exceptions]. 

[^exceptions]: The primary exception is where there's some work that can shared across multiple users. For example, all users might be looking at the same large csv file, so you might as well load it once and share it between users. We'll come back to that idea in Chapter XYZ.

Server functions take three parameters: `input`, `output`, and `session`[^session-optional]. You'll never create these objects yourself; instead, they're created by Shiny when the session begins. Each combination of the three arguments connects back to a specific session, and you use those objects to communicate back and forth with the browser. For the moment, we'll focus on `input` and `output`, and leave `session` for later chapters.

[^session-optional]: For legacy reasons, `session` is optional, but you should always include it.

### Input {#input}

The `input` argument is a list-like object that contains all the input data sent from the browser, named according to the input ID. For example, if your UI contains a numeric input control with an input ID of `count`, like so:

```{r}
ui <- fluidPage(
  numericInput("count", label = "Number of values", value = 100)
)
```

Then you can access the value of that input with `input$count`. It will initially contain the value `100`, and it will be automatically updated as the user changes the value in the browser.

Unlike a typical list, `input` objects are read-only. If you attempt to modify an input inside the server function, you'll get an error:

```{r, eval = FALSE}
server <- function(input, output, session) {
  input$count <- 10  
}

shinyApp(ui, server)
#> Error: Attempted to assign value to a read-only reactivevalues object
```

This error occurs because `input` reflects what's happening in the browser, and the browser is the "single source of truth". If you could modify the value in R, you could introduce inconsistencies where the input slider said one thing in the browser, and `input$count` said something different in R. That would make programming challenging!

It is possible, however, to change the value in the browser using `updateNumericInput()`, and then `input$count` will update accordingly. We'll come back to that idea in Chapter XYZ, where we discuss dynamic user interfaces.

One more important thing about `input`: it's selective about who is allowed to read it and you must be in a __reactive context__ to see its value. We'll come back to that idea very shortly, but it's a fundamentally important constraint that allows outputs to automatically update when an input changes. You can see the problem with this server function:

```{r, eval = FALSE}
server <- function(input, output, session) {
  message("The value of input$count is ", input$count)
}

shinyApp(ui, server)
#> Error: Operation not allowed without an active reactive context. 
#> (You tried to do something that can only be done from inside 
#> a reactive expression or observer.)
```

### Output {#output}

The `output` argument is a list-like object that allows you to send data to the browser, named according to the output ID. The various `*Output` UI functions---`plotOutput()`, `tableOutput()`, `textOutput()`, and friends---merely insert empty boxes, or placeholders, into your UI. The `output` object allows you to populate these these empty boxes.

You always use the `output` object in concert with a `render` function, as in the following simple example: 

```{r}
ui <- fluidPage(
  textOutput("greeting")
)

server <- function(input, output, session) {
  output$greeting <- renderText({
    "Hello human!"
  })
}
```

The render function does two things:

* It sets up a reactive context that automatically tracks what inputs 
  you use.
  
* It converts the output of your R code into HTML suitable for display
  in the output control.

(Note that the ID is quoted in the UI, but not in the server.)

Like the `input`, the `output` is picky about how you use it. If you forget the `render` function you'll get an error:

```{r, eval = FALSE}
server <- function(input, output, session) {
  output$greeting <- "Hello human"
}
shinyApp(ui, server)
#> Error: Unexpected character output for greeting
```

And if you attempt to read from an output you'll get an error:

```{r, eval = FALSE}
server <- function(input, output, session) {
  message("The greeting is ", output$greeting)
}
shinyApp(ui, server)
#> Error: Reading objects from shinyoutput object not allowed.
```

You must always write to an output with a render function.

## Reactive programming

An app is going to be pretty boring if it only has inputs or only has outputs. The real magic of Shiny happens when you have an app with both. Let's look at a simple example:

```{r}
ui <- fluidPage(
  textInput("name", "What's your name?"),
  textOutput("greeting")
)

server <- function(input, output, session) {
  output$greeting <- renderText({
    paste0("Hello ", input$name, "!")
  })
}
```

It's hard to show exactly how this works in a book, but if you run the app, and type in the name box, you'll notice that the greeting updates automatically as you type:

```{r, echo = FALSE, out.width = "25%", fig.show="hold"}
app <- testApp(ui, server)
app_screenshot(app, "basic-reactivity/connection-1", width = 200)
app$setInputs(name = "J")
app_screenshot(app, "basic-reactivity/connection-2", width = 200)
app$setInputs(name = "Jo")
app_screenshot(app, "basic-reactivity/connection-3", width = 200)
app$setInputs(name = "Joe")
app_screenshot(app, "basic-reactivity/connection-4", width = 200)
```

(If you're running the live app, notice that you have to type fairly slowly for the output to update one letter at a time. That's because shiny uses a technique called __debouncing__, which means that it waits for XYZ ms before sending an update. That reduces the amount of needless work that Shiny needs to do, without appreciably reducing the response time of the app.)

This is the big new idea in Shiny: you don't need to specify when the output code is run because Shiny automatically figures it out for you. How does it  work? What exactly is going on in the body of the function?

```{r, eval = FALSE}
output$greeting <- renderText({
  paste0("Hello ", input$name, "!")
})
```

It's easy to read the code above as "paste together 'hello' and the user's name, then send it to `output$greeting`". But this mental model is wrong in a subtle but important way. Think about it: you only issue the instruction once, but Shiny might perform the action multiple times.

That's because this code doesn't _tell_ Shiny to create the string and send it to the browser, but instead, it informs Shiny _how it could_ create the string if it needs to. It's totally up to Shiny whether and when to actually run the code; maybe right away, maybe quite a bit later, maybe many times, maybe never. This isn't to imply that Shiny is capricious and arbitrary, only that it's Shiny's responsibility, not yours, to decide when render logic is actually executed. In short, you don't give Shiny commands, you give Shiny recipes.

### Imperative and declarative programming

This is the key difference between two important styles of programming:

* In __imperative__ programming, you issue a specific command and it's 
  carried out immediately. This is the style of programming you're used to
  in your analysis scripts: you command R to load your data, manipulate it,
  visualise it, and save the results to disk.
  
* In __declarative__ programming, you express higher-level goals or
  describe important constraints, and rely on someone else to decide how
  and/or when to translate that into action. This is the style of 
  programming you use in Shiny.

Imperative code says: "Make me a sandwich". Declarative code says: "Ensure there is a sandwich in the refrigerator whenever I open it." (Sorry, sometimes Declarative can be a passive-aggressive jerk.)

Most of the time, declarative programming feels tremendously freeing: you describe your overall goals, and the software figures out how to achieve them without further intervention. The downside is that 5% of the time where you just want to say "DO THIS! DO IT NOW" and you can't figure out how to describe your simple instructions into a set of motivations. (If you've ever struggled with getting a ggplot2 legend to look exactly the way you want, you've encountered this problem). The goal of this book is to decrease that feeling as much as possible!

The other downside of declarative programming is that it can write code that makes sense but doesn't do what you want. One easy way to do this in Shiny is by accidentally mismatching an input or output id. For example, can you spot what's wrong with this code?

```{r}
server <- function(input, output, session) {
  output$greetnig <- renderText({
    paste0("Hello ", input$name, "!")
  })
}
```

This code is valid, but not very useful: it will wait forever for `greetnig` ouput to exist. If you're working on a shiny app, and you just can't figure out why your code never gets run, make sure that your UI and server functions are using the same names.

### The reactive graph

One of the most confusing things about Shiny is that the order of the code in your server function is unrelated to the order in which it is executed. To understand what's happening it's often useful to look at the __reactive graph__, which describes how inputs and outputs are connected. 

The reactive graph for the app above is very simple:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/graph-1b.png", dpi = 300)
```

Note the graphical conventions we used for the inputs and outputs. The `name` input naturally fits into the `greeting` output. We could draw them almost touch, as below. That style doesn't work well for more complex apps, so we won't use it very often, but it should help you remember why the shapes look like they do.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/graph-1a.png", dpi = 300)
```

Reactive expressions allow you to extract out repeated computation into a single home. There's not much point in using one for this simple app, but I will, just to show you what the correspond diagram looks like:

```{r}
server <- function(input, output, session) {
  text <- reactive(paste0("Hello ", input$name, "!"))
  output$greeting <- renderText(text())
}
```

Reactive expressions take inputs and produce outputs so they have a shape that combines features of inputs and outputs:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/graph-2b.png", dpi = 300)
```

Again, you could imagine packing them altogether, but this only works for very simple graphs.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/graph-2a.png", dpi = 300)
```

It's good practice to lay out your server function to match the flow of the graph. For example, the following code is perfectly valid, but is going to be confusing to humans.

```{r}
server <- function(input, output, session) {
  output$greeting <- renderText(text())
  text <- reactive(paste0("Hello ", input$name, "!"))
}
```

In our experience, as your app gets more complicated, it's often useful to make a quick high-level sketch of the reactive graph. Later on, in Chapter XYZ, you'll learn about Shiny's reactlog which will draw the graph for you, and animate how it changes as you run the app.

## Case study

Let's put all these ideas together 

```{r}
ui <- fluidPage(
  fluidRow(
    column(4, 
      "Distribution 1",
      numericInput("n_1", label = "n", value = 1000, min = 1),
      numericInput("mean_1", label = "µ", value = 0, step = 0.1),
      numericInput("sd_1", label = "σ", value = 0.5, min = 0.1, step = 0.1)
    ),
    column(4, 
      "Distribution 2",
      numericInput("n_2", label = "n", value = 1000, min = 1),
      numericInput("mean_2", label = "µ", value = 0, step = 0.1),
      numericInput("sd_2", label = "σ", value = 0.5, min = 0.1, step = 0.1)
    ),
    column(4,
      "Histogram",
      numericInput("bins", label = "Bins", value = 20, min = 1),
      sliderInput("range", label = "range", value = c(-3, 3), min = -5, max = 5)
    )
  ),
  fluidRow(
    column(9, plotOutput("hist")),
    column(3, verbatimTextOutput("ttest"))
  )
)

server <- function(input, output, session) {
  output$hist <- renderPlot({
    x1 <- rnorm(input$n_1, input$mean_1, input$sd_1)
    x2 <- rnorm(input$n_2, input$mean_2, input$sd_2)
    
    hist(c(x1, x2), breaks = input$bins, xlim = input$range)
  })
  
  output$ttest <- renderText({
    x1 <- rnorm(input$n_1, input$mean_1, input$sd_1)
    x2 <- rnorm(input$n_2, input$mean_2, input$sd_2)
    
    test <- t.test(x1, x2)
    sprintf("p value: %0.3f\n[%0.2f, %0.2f]", 
      test$p.value, test$conf.int[1], test$conf.int[2]
    )
  })
}
```

### Outputs are atomic

Shiny is smart enough to discern that an output needs to be updated. However, it's not nearly smart enough to know if it can get away with running only part of the output's code block. For example, the code for `hist_plot` has two lines:

```{r, eval = FALSE}
output$hist <- renderPlot({
  x1 <- rnorm(input$n_1, input$mean_1, input$sd_1)
  x2 <- rnorm(input$n_2, input$mean_2, input$sd_2)
  
  hist(c(x1, x2), breaks = input$bins, xlim = input$range)
})
```

As a human looking at this code, you might conclude that when `input$bins` changes, it's not necessary to re-run both lines; if we still had access to the existing `values` variable, merely running the second line might be enough.

This leads to the following reactive graph where there are many connections.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/case-study-1.png", dpi = 300)
```

* Every input is connected directly to every output. This makes the app hard
  to understand. If you can't understand a picture, you'll struggle to 
  understand the app. When we change the breaks of the plot, the data is 
  recalculated! We we change the value of `n_1`, `x2` is updated! This means
  our app is doing a lot more work than necessary.

### Reactive expressions

There are a few problems with this app:
  
* There's a major flaw in the app: the simulations are independent: the results
  from the t-test don't actually correspond to the data used in the histogram.

We can fix both of those problems by taking advantage of reactive expressions to perform the individual simulations. This makes both the server function and the reactive graph simpler, and ensures that we're using the same data in all places. 

```{r}
server <- function(input, output, session) {
  x1 <- reactive(rnorm(input$n_1, input$mean_1, input$sd_1))
  x2 <- reactive(rnorm(input$n_2, input$mean_2, input$sd_2))
  
  output$hist <- renderPlot({
    hist(c(x1(), x2()), breaks = input$bins, xlim = input$range)
  })
  
  output$ttest <- renderText({
    test <- t.test(x1(), x2())
    sprintf(
      "p value: %0.3f\n[%0.2f, %0.2f]", 
      test$p.value, test$conf.int[1], test$conf.int[2]
    )
  })
}
```

This makes the reactive graph substantially simpler because we can more easily break it down into independent pieces.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/case-study-2.png", dpi = 300)
```

Reactive expressions are extremely important for creating efficient shiny apps because they are only updated when their inputs change. This means that you can use them to encapsulate expensive operations so that they are only re-computed the minimal number of times. If you have every used a tool like `make`, this might seem familiar.

### Reactive roadblocks {#reactive-expressions-intro}

But first let's look at two approaches that don't work.

Using a variable won't work:

```{r, eval = FALSE}
# Don't do this!
server <- function(input, output, session) {
  dataset <- get(input$dataset, "package:datasets", inherits = FALSE)

  output$summary <- renderPrint({
    summary(dataset)
  })
  
  output$table <- renderTable({
    dataset
  })
}
```

In this code, we're attempting to calculate the value of `dataset` just once, as the session starts. But the value of `input$dataset` may change over time. We noted a few paragraphs ago that Shiny outputs are reactive (they re-execute as necessary); the same cannot be said for free-floating code like this. So the result of extracting a variable like this is tha the `dataset` variable will assume some value at startup based on the initial value of `input$dataset`, and stay at that value forever. This is clearly not what we want, and is such an easy trap to fall into that in fact Shiny detects this condition and throws an error immediately.

If using a variable won't work, how about a function? This will work, and takes care of the code duplication, but it does result in duplicated effort:

```{r, eval = FALSE}
# Don't do this!
server <- function(input, output, session) {
  getDataset <- function() {
    get(input$dataset, "package:datasets", inherits = FALSE)
  }

  output$summary <- renderPrint({
    summary(getDataset())
  })
  
  output$table <- renderTable({
    getDataset()
  })
}
```

We get the correct behavior this time, at least—we're calling `getDataset()` from within our output code, so Shiny will know to recalculate the outputs when `input$dataset` changes. However, for each change to `input$dataset`, `getDataset` is going to be called twice, and its work is therefore going to be performed twice. (In this example, the work being done in `getDataset` is totally trivial so it doesn't actually matter; just imagine we're doing a more expensive operation like retrieving a dataset from a web service or database, or fitting a model over a large dataset, or performing simulations.)

To summarize: while variables calculate the value only once (not often enough), and functions calculate the value every time they're called (too often), reactive expressions calculate the value only when it might have changed (just right!).

## Controlling timing of evaluation

### Waiting longer

Simulation example - if the simulation is slow, you don't want to kick it off as soon as you make one little change. Two approaches: you could debounce (i.e. only update when you've paused your modifications), or you could make a button.

```{r, eval = FALSE}
x1 <- eventReactive(input$simulate, rnorm(input$n_1, input$mean_1, input$sd_1))
x2 <- eventReactive(input$simulate, rnorm(input$n_2, input$mean_2, input$sd_2))
```

```{r, eval = FALSE}
data <- eventReactive(
  debounce(list(input$n, input$mean, input$sd), 250), 
  rnorm(input$n, input$mean, input$sd)
)
```

Later on you'll learn about tools like `reactiveFileReader()`

### Timed invalidation

The flip side is that sometimes you need to update the app when something outside the app has changed. i.e. you need to invalid more often that the reactivity graph would otherwise suggest.

```{r}
server <- function(input, output, session) {
  timer <- reactiveTimer(250)
  x1 <- reactive({
    timer()
    rnorm(input$n_1, input$mean_1, input$sd_1)
  })
  x2 <- reactive({
    timer()
    rnorm(input$n_2, input$mean_2, input$sd_2)
  })
  
  output$hist <- renderPlot({
    hist(c(x1(), x2()), breaks = input$bins, xlim = input$range)
  })
  
  output$ttest <- renderText({
    test <- t.test(x1(), x2())
    sprintf(
      "p value: %0.3f\n[%0.2f, %0.2f]", 
      test$p.value, test$conf.int[1], test$conf.int[2]
    )
  })
}
```

## Side-effects

* Saving a file to disk
* Talking to a web API
* Updating a database record
* Printing to screen (for debugging or loggin)

`observeEvent()`
