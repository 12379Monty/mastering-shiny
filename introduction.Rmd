# Introduction

```{r include = FALSE}
source("common.R")
```

## What is Shiny?

## What you will learn

If you've never used Shiny before, welcome! 

The first part of the book, "Getting started", is designed to get you up and running with Shiny as quickly as possible. This is pretty quick, because Shiny is carefully designed to let you get started writing apps as quickly as possible. We'll teach you a few recipes to follow that let you turn your existing R code into basic apps by wrapping key bits of code in `reactive({...})` or `renderXXX({...})`.

In "Shiny in Action", you'll learn a bunch of common patterns for building Shiny apps.

Then in "Mastering UI", you'll dive further into the many options you have for the front-end of your app.

In "Mastering reactivity", you'll go deep in to the theory and practice of reactive programming, the programming paradigm that underlies Shiny. If you're an existing Shiny user, you'll get the most value out of this chapter as it will give you a solid theoretical underpinning that will allow you to create new tools specifically tailored for your problems.

The biggest drawback of reactive programming is that it's a fundamentally new programming paradigm. Even experienced R users can have trouble getting their heads around reactive programming, and those with deep experience in software engineering may feel uncomfortable with so much "magic". But once you've formed an accurate mental model, you'll see that there's nothing up Shiny's sleeves: the magic comes from simple concepts combined in consistent ways.

Finally, in "Taming Shiny" we'll finish up a survey of useful techniques for making your Shiny apps work well in production. You'll learn how to measure and improve performance, debug problems when they go wrong, and manage your app's dependencies.

## What you won't learn

The focus of this book is making effective Shiny apps and understanding the underlying theory of reactivity. I'll do my best to show off best practices for data science, R programming, and software engineering at the same time as well, but you'll need other references to master these other important components.

## Prerequisites {#prerequisites}

The first thing you'll need to do is install the software you'll need, if you don't have it already:

### R {-}

If you don't have R installed already, you may be reading the wrong book; you need to be proficient with R if you want to write Shiny apps. If you'd like to learn how to use R, I'd recommend my [_R for Data Science_](https://r4ds.had.co.nz/) book which is designed to get you up and running with R with minimum of fuss.

### RStudio {-}

RStudio is a free and open source *integrated development environment* (IDE) for R: a single program that includes a code editor, R console, graphics device, and many features for working productively with R.

While you can write and use Shiny apps with any R environment (including R GUI and [ESS](http://ess.r-project.org)), RStudio has some nice features specifically for authoring, debugging, and deploying Shiny apps. We recommend giving it a try, but it's not required to be successful with Shiny or with this book.

You can download RStudio Desktop at <https://www.rstudio.com/products/rstudio/download>

### Shiny {-}

Shiny is an R package; you install it the same way you install any R package. From the R console:

```{r eval=FALSE}
install.packages("shiny")
```

### Other R packages {-}

This book is heavy on code, and we will often use other R packages in our examples. You can install them all now by running this code:

```{r eval=FALSE}
install.packages(c("magrittr", "lubridate", "readr", "dplyr", "ggplot2", "gt"))
```

TODO: Update this list before final draft; see [DESCRIPTION](https://github.com/hadley/mastering-shiny/blob/master/DESCRIPTION) for the definitive list.

## Cheat sheet

You may find it helpful to print a copy of our [Shiny "cheat sheet"](https://github.com/rstudio/cheatsheets/raw/master/shiny.pdf), a reference card for many of the most important concepts and functions in Shiny. It won't all make sense to you yet, but as you work through the chapters you'll find it more and more helpful to refresh your memory.

## If you get stuck {#reprex}

Do you have a problem you can't figure out, or a question that this book (and Google) can't answer? The best place to ask is the Shiny community site,  <https://community.rstudio.com/c/shiny>. This site is read by many Shiny users, as well as the developers of the Shiny package itself. It's also a great place to visit if you want to improve your Shiny skills by helping others.

To get the most useful help as quickly as possible, you must create a reprex, or **repr**oducible **ex**ample. The goal of a reprex is to provide the smallest possible snippet of R code that illustrates the problem and can easily be run on another computer. It's common courtesy (and in your own best interest) to create a reprex: if you want someone to help you, you should make it as easy as possible for them!

### Reprex basics

A reprex is just some R code that works when you copy and paste it into a R session on another computer. Here's a simple reprex for a Shiny app:

```{r, eval = FALSE}
library(shiny)
ui <- fluidPage(
  selectInput("n", "N", 1:10),
  plotOutput("plot")
)
server <- function(input, output, session) {
  output$plot <- renderPlot({
    n <- input$n * 2
    plot(head(cars, n))
  })
}
shinyApp(ui, server)
```

This code doesn't make any assumptions about the computer on which its running (except that Shiny is installed!) so anyone can run this code and see the problem: the app throws an error saying "non-numeric argument to binary operator". 

Clearly illustrating the problem is the first step to getting help, and because anyone can reproduce the problem by just copying and pasting the code, they can easily explore your code and test possible solutions. (In this case, you need `as.numeric(input$n)` since `selectInput()` creates a string.)

### Making a reprex

The first step in making a reprex is to create a single self-contained file that contains everything needed to run your code. You should check it by starting a fresh R session and then running the code. Make sure you haven't forgotten to load any packages[^library] that make your app work.

[^library]: Regardless of how you normally load packages, I strongly recommend using multiple `library()` calls. This eliminates a source of potential confusion for people who might not be familiar with the tool that you're using.

Typically, the most challenging part of making an app work on another computer is eliminating the use of data that's only stored on your computer. To turn your code into a reprex, you need to provide the needed data inline in the reprex, without assuming that there are any other files on disk. This can be either your original data set, or a simplified version of it that still causes the issue. For example, if you have a data frame with 1,000 rows, you might try to take the first 20 rows and see if that will still cause the problem. In general it is best to provide a simplified version of the data set, so that it is easy for others to understand it.

*   Use a built-in data set like `mtcars` or `iris`.

*   Provide regular R code that generates a data set. For example:

    ```{r}
    mydata <- data.frame(x = 1:5, y = c("a", "b", "c", "d", "e"))
    ```

*   Use `dput()` to turn an existing data frame into executable code.
    `dput(mydata)` generates the code you need to recreate `mydata`:
    
    ```{r}
    dput(mydata)
    ```
  
    Once you have that code, you can put this in your reprex to generate 
    `mydata`:
    
    ```{r}
    mydata <- structure(list(x = 1:5, y = structure(1:5, .Label = c("a", "b", 
    "c", "d", "e"), class = "factor")), class = "data.frame", row.names = c(NA, 
    -5L))
    ```

    If `dput()` on your original data generates too much code, try taking a 
    subset of your data and see if it will reproduce the problem.

If reading data from disk seems to be an irreducible part of the problem, a strategy of last resort is to provide a complete project containing both an `app.R` and the needed data files. The best way to do provide this is as a RStudio project hosted on GitHub, but failing that, you can carefully make a zip file than can be run locally. Make sure that you use relative paths (i.e. `read.csv("my-data.csv"`) not `read.csv("c:\\my-user-name\\files\\my-data.csv")`) so that your code still works when run from a different location.

### Making a minimal reprex

Creating the smallest possible reprex is particularly important for Shiny apps, which can be quite large and complicated. Rather than forcing the person trying to help you to understand all the details of your app, you are more likely to get higher quality help faster if you can extract out the exact piece of the app that you're struggling with. As an added benefit, this process will often lead you to discover what the problem is, so you don't have to wait for help from someone else!

Reducing a bunch of code to the essential problem is a skill, and you probably won't be very good it at first. That's ok! Even the smallest reduction in code complexity helps the person helping you, and over time your compexity reduction skills will approve.

If you don't know what part of your code is triggering the problem, a good way to find it is to remove sections of code from your application, piece by piece, until the problem goes away. If removing a particular piece of code makes the problem stop, it's likely that that code is related to the problem. Alternatively, sometimes it's simpler to start with a fresh, empty, app and progressively build it up until you find the problem again.

Once you've simplified your app to demonstrate the problem, it worthwhile to take a final pass through and check:

* Is every input and output in `UI` related to the problem? 

* Does your app have a complex layout that you can simplify to help focus 
  on the problem at hand?
  
* Have you created reactives in `server()` that aren't pertinent to the 
  problem?
  
* If you've tried multiple ways to solve the problem, have you removed all
  the vestiges of the attempts that didn't work?
  
* Is every package that you load needed to illustrate the problem? Can you
  eliminate packages by replacing functions with dummy code?

### Case study

To illustrate the process of making a top-notch reprex I'm going to use an example from [Scott Novogoratz](https://community.rstudio.com/u/sanovogo) posted on [RStudio community](https://community.rstudio.com/t/37982). The initial code was very close to being a reprex, but wasn't quite reproducible because it forgot to load a pair of packages. At as a starting point: 

* Added missing `library(lubrdate)` and `library(xts)`.
* Split apart `ui` and `server` into separate objects.
* Reformatted with `styler::style_selection()`.

That yielded the following reprex:

```{r, eval = FALSE}
library(xts)
library(lubridate)
library(shiny)

ui <- fluidPage(
  uiOutput("interaction_slider"),
  verbatimTextOutput("breaks")
)
server <- function(input, output, session) {
  df <- data.frame(
    dateTime = c(
      "2019-08-20 16:00:00",
      "2019-08-20 16:00:01",
      "2019-08-20 16:00:02",
      "2019-08-20 16:00:03",
      "2019-08-20 16:00:04",
      "2019-08-20 16:00:05"
    ),
    var1 = c(9, 8, 11, 14, 16, 1),
    var2 = c(3, 4, 15, 12, 11, 19),
    var3 = c(2, 11, 9, 7, 14, 1)
  )

  timeSeries <- as.xts(df[, 2:4], order.by = strptime(df[, 1], format = "%Y-%m-%d %H:%M:%S"))
  print(paste(min(time(timeSeries)), is.POSIXt(min(time(timeSeries))), sep = " "))
  print(paste(max(time(timeSeries)), is.POSIXt(max(time(timeSeries))), sep = " "))

  output$interaction_slider <- renderUI({
    sliderInput(
      "slider",
      "Select Range:",
      min = min(time(timeSeries)),
      max = max(time(timeSeries)),
      value = c(min, max)
    )
  })

  brks <- reactive({
    req(input$slider)
    seq(input$slider[1], input$slider[2], length.out = 10)
  })

  output$breaks <- brks
}
shinyApp(server, ui)
```

If you run this reprex, you'll see the same problem in the initial post: an error starting "Type mismatch for min, max, and value. Each must be Date, POSIXt, or number". This is a solid reprex: I can easily run it on my computer, and it immediately illustrates the problem. However, it's a bit long, so it's not clear what's causing the problem.

To make this reprex simpler we can carefully work through each line of code and see if it's important. While doing this, I discovered:

* Removing the the two lines starting with `print()` didn't affect the error. 
  Those two lines used `lubridate::is.POSIXct()`, which was the only use of 
  lubridate, so once I removed them, I no longer needed to load lubridate.
  
* `df` is a data frame that's converted to an xts data frame called 
  `timeSeries`. But the only way `timeSeries` is used is via 
  `time(timeSeries)` which returns a date-time. So I created
  a new variable `datetime` that contained some dummy date-time data.
  This still yielded the same error, so I removed `timeSeres` and `df`,
  and since that was the only place xts was used, I also removed
  `library(xts)`

Together, those changes yielded a new `server()` that looked like this:

```{r}
datetime <- Sys.time() + (86400 * 0:10)

server <- function(input, output, session) {
  output$interaction_slider <- renderUI({
    sliderInput(
      "slider",
      "Select Range:",
      min   = min(datetime),
      max   = max(datetime),
      value = c(min, max)
    )
  })
  
  brks <- reactive({
    req(input$slider)
    seq(input$slider[1], input$slider[2], length.out = 10)
  })
  
  output$breaks <- brks
}
```

Next, I noticed that this example uses a relatively sophisticated Shiny technique where the UI is generated in the server function. But here `renderUI()` is not referring to any reactive inputs, so it should work the same way if moved out of the server function and into the UI. 

This yielded a particularly nice results, because now the error occurs much earlier, before we even start the app:

```{r, error = TRUE}
ui <- fluidPage(
  sliderInput("slider",
    "Select Range:",
    min   = min(datetime),
    max   = max(datetime),
    value = c(min, max)
  ),
  verbatimTextOutput("breaks")
)
```

And now we can take the hint from the error message and look at each of the inputs we're feeing to `min`, `max`, and `value` to see where the problem is:

```{r}
min(datetime)
max(datetime)
c(min, max)
```

Now the problem is obvious: we've haven't assigned `min` and `max` variables, so we're accidentally passing the `min()` and `max()` functions into `sliderInput()`. One way to solve that problem is to use `range()` instead:

```{r}
ui <- fluidPage(
  sliderInput("slider",
    "Select Range:",
    min   = min(datetime),
    max   = max(datetime),
    value = range(datetime)
  ),
  verbatimTextOutput("breaks")
)
```

This is fairly typically of creating a reprex: often, when you simplify the problem to the absolute key components the problem becomes obvious. Creating a good reprex is an incredibly powerful debugging technique.

To simplify this reprex, I had to do a bunch of experimenting and reading up on functions that I wasn't very familiar with[^is.POSIXt]. This is typically much easier if its your own code, because you already understand what all the parts do. Still, you'll often need to do a bunch of experimentation to figure out where exactly the problem is coming from. That can be frustrating and feel time consuming, but it has a number of benefits:

* It enables you to create a description of the problem that is accessible to
  anyone who knows Shiny, not anyone who knows Shiny **and** the particular
  domain that you're working in.

* You will build up a better mental model of how your code works, which means
  that you're less likely to make the same or similar mistakes in the future.

* Over time, you'll get faster and faster at creating rexpres, and this will
  become one of your go to techniques when debugging.

[^is.POSIXt]: For example, I had no idea that `is.POSIXt()` was part of the lubridate package!

## Acknowledgements

This book was written in [bookdown](http://bookdown.org/) inside [RStudio](http://www.rstudio.com/ide/). The [website](http://mastering-shiny.org/) is hosted with [netlify](http://netlify.com/), and automatically updated after every commit by [travis-ci](https://travis-ci.org/). The complete source is available from [GitHub](https://github.com/hadley/mastering-shiny). 

```{r, echo = FALSE}
ruler <- function(width = getOption("width")) {
  x <- seq_len(width)
  y <- dplyr::case_when(
    x %% 10 == 0 ~ as.character((x %/% 10) %% 10),
    x %% 5 == 0  ~ "+",
    TRUE         ~ "-"
  )
  cat(y, "\n", sep = "")
  cat(x %% 10, "\n", sep = "")
}
```
```{r}
ruler()
```
