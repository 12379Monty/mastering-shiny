# Reducing duplication with modules {#action-modules}

```{r, include = FALSE}
source("common.R")
```

As your Shiny app grows you will find it increasingly hard to understand how all the pieces fit together, and you may find that any change you make creates news problems that you have to fix before continuing. This is a particularly problem as soon as your UI or server grows beyond the point that it can fit on one screen, or you find it hard to keep all the pieces fit together in your head simultaneously.

When this happens to you, it's a good time to consider using Shiny modules. Shiny modules require a learning a couple of new ideas (particularly namespacing), but have a big payoff because they enable you to write much more ambitious apps because they support greater isolation and easier reuse:

*   Modules isolate subcomponents of your app so that they can only communicate
    is specified ways. This makes it easier to understand how your app works 
    because you can write, analyse, and test individual components by 
    themselves. Modules also provide a standard way of spreading your app 
    across multiple files.
    
*   Modules support reuse of client-side HTML and server-side behaviour by
    wrapping repeated code into functions that can be called in multiple
    places in your app.

These benefits might sound familiar because they're very similar to the benefits that functions bring to your R code. And that's not a surprise because modules are just functions with a specific structure. This means anything you can do with a function, you can do with a module.

```{r setup}
library(shiny)

# This is a new style of module construction that will appear in shiny 1.5.0.
# For now, we're adding a simple shim that you can use in your own, and delete
# when shiny 1.5.0 is out.
moduleServer <- function(id, module) {
  callModule(module, id)
}
```

## Motivation {#module-motivation}

For example, this diagram shows the rough outline of a moderately complex app for performing simulations, as used by Eric Nantz in his rstudio::conf(2019) talk on modules (https://www.youtube.com/watch?v=ylLLVo2VL50). This is a complicated diagram!

This digram shows the benefits that modules bring:

* They divide a big complex app into pieces that you can name.

* A module is a black box with definied inputs and outputs. Like a function,
  you can reach inside a module and read or write. This simplifies the overall
  flow.

* Modules are reusable so we can write one function generates both yellow 
  and both blue components.

These are not discrete cases, but points of a spectrum:

* No inputs or outputs
* Inputs or outputs
* Inputs and outputs
* A module designed specifically for reuse across multiple apps; possibly
  bundled into an R package and distributed widely across multiple 
  organisations.

Often the hardest part is decomposing your big problem into smaller independent pieces. I include some case studies here to help you get a sense of how this feels, but ultimately it's a skill that can only be learned with practice. Try and set aside some time each week where you're not improving the behaviour or appearance of your app, but simply making it easier to understand. This will make your app easier to change in the future, and as you practice these skills your first attempt will become higher quality.

## Module basics

A module is just a pair of functions. One function is responsible for generating the UI components; one function is responsible for generating the server function. Both functions take "id" as the first argument, and use it in a standard way. This is the key difference with modules, and is what guarantees their isolation and allows you to use them multiple times in the same app.

Let's take a very simple app and divide it up into modules. This app is so simple that there's no real benefit to modularising it, but it will serve to illustrate the main differences with modules before we dive into more realistic use cases. This app draws a plot of a histogram for user selected variable and number of bins.

```{r}
ui <- fluidPage(
  selectInput("var", "Variable", names(mtcars)),
  numericInput("bins", "bins", 10, min = 1),
  plotOutput("hist")
)
server <- function(input, output, session) {
  data <- reactive(mtcars[[input$var]])
  output$hist <- renderPlot({
    hist(data(), breaks = input$bins, main = input$var)
  })
}
```

### Module UI

To turn this into a module we need to turn theUI and server components into functions with a special form. We'll start with the UI. There are two steps:

* We wrap it inside a function. The function must take an `id` argument.
  Going from a specific UI to a recipe for how to create a UI; modules
  designed for reuse in multiple places will tend to have more arguments.
  
* Each existing ID needs to get "namespaced". Practically this means you
  transform (e.g.) `"var"` to `NS(id, "var")`. The key idea is that the first 
  argument to `NS()` is supplied by the user of the module, and the second 
  argument is supplied by the author of the module. This two-part creation 
  means that you as a module author don't need to worry about clashing with
  other UI components created by the user. You have your own "space" of names
  that you control. This is the key idea of namespaces.

This yields the following function:

```{r}
histogramUI <- function(id) {
  list(
    selectInput(NS(id, "var"), "Variable", names(mtcars)),
    numericInput(NS(id, "bins"), "bins", 10, min = 1),
    plotOutput(NS(id, "hist"))
  )
}
```

Note that here we return the UI components in a list; that means they will get included in the parent container when added to the final UI. Returning a list is most flexible because it allows the caller of the module to put it in whatever container they want. But if in your app, you always place the module in the same container you might want to include that in the UI function and instead return a `column()` or a `fluidRow()`.

(If you're using dynamic UI, you need one extra little trick - you can get the current namespace through `session$ns`; and you don't need to expicitly pass `id`.)

### Module server

Next we tackle the server function. This gets wrapped inside a another function which must have an `id` argument (again, it can have other arguments and we'll come back to those shortly): again this function is a recipe for generating the code needed inside the server function.

The module server calls `moduleServer()` with the id, and a function that looks like a regular server function. This always has arguments `input`, `output`, and `session`.

```{r}
histogramServer <- function(id) {
  moduleServer(id, function(input, output, server) {
    data <- reactive(mtcars[[input$var]])
    output$hist <- renderPlot({
      hist(data(), breaks = input$bins, main = input$var)
    })
  })
}
```

It's important to note that code inside the module server is isolated: it can only read from inputs and write to outputs defined with the matching `id`. If you want to take input from reactives elsewhere in the app, you'll need to pass them to the module function explicitly; we'll come back to that later.

Note that the namespacing in the UI is explicit; you have to manually instrument each `id` argument with `NS()`. The namespace in the server is **implicit**; Shiny automatically modifies the `input` and `output` arguments so work it works automatically without your intervention.

### Updated app

Now that we have these pieces we can rewrite our app to use them:

```{r}
ui <- fluidPage(
  histogramUi("hist1")
)
server <- function(input, output, session) {
  histogramServer("hist1")
}
```

Note that, just like regular inputs/output and reactives the UI and server are linked by a shared ID. Otherwise they're black boxes and you can't see inside them. Shortly we'll see how you can add inputs and outputs to your reactives so that they can interact with other parts of your app.

I think it's good practice to create a "module" function that makes it easy to instantiate a version of your module as a complete. This should live at the bottom of the file. This allows you to experiment with your module independently of the rest of your app. More complicated modules are likely to require a couple of other inputs or output in order to simulate the inputs and outputs to the module.

```{r}
histogramModule <- function() {
  ui <- fluidPage(
    histogramUI("hist1")
  )
  server <- function(input, output, session) {
    histogramServer("hist1")
  }
  shinyApp(ui)  
}
```

### Naming scheme

Before we continue on, it's worth reflecting on the naming scheme I've used here. Since the module is about histograms, the base name is `histogram`. I then use that name in various places:

* `R/histogram.R`: where the code lives.

* `histogramUI()`: the function that generates the UI. If it provide solely 
  input or output controls I'd call it `histogramInput()` or `histogramOuput()`.

* `histogramServer()`: the function that generates the server function.

* `histogramModule()`: a function that creates a complete app for testing.

### Advantages

There are two big advantages to using a module: isolation and reuse.

Firstly all the code inside the histogram is isolated. The UI below would still work because the histogram module is isolated from the new bins input. You can imagine how helpful this would be when working with large apps!

```{r}
ui <- fluidPage(
  histogramUI("hist1"),
  sliderInput("bins", "bins", 5, min = 1, max = 10)
)
```

The other advantage is that you can easily reuse in multiple places in the app:

```{r}
ui <- fluidPage(
  histogramUI("hist1"),
  histogramUI("hist2")
)
server <- function(input, output, session) {
  histogramServer("hist1")
  histogramServer("hist2")
}
```

This is not very useful here because there are no other parameters.

## Inputs and outputs

Module UI and server function must always have an `id` argument. But there's no reason that they can't have arguments. And indeed this is the way to pass extra data to your reactives. (You might see advice on-line to use `session$userData`. I think this is generally bad advice because it takes an end run around namespacing and re-introduces many of the problems that you're trying to avoid by using modules. )

You'll need to think carefully about whether an argument should be a reactive or not. If it's a reactive, that means you module need to respond to changes in its. If it's not a reactive, then it only influences the set up of the module. This also influences how you call module servers:

* Should you pass a reactive or the current value of a reactive? Always reactive! Only take a constant if it's something that is used only during the setup of your module code.

* Passing `input$foo` is almost certainly wrong.

### Summary

```{r}
selectNumericVarInput <- function(id) {
  selectInput(NS(id, "var"), "Variable", choices = NULL) 
}

selectNumericVarServer <- function(id, df) {
  moduleServer(id, function(input, output, session) {
    observeEvent(df(), {
      is_numeric <- vapply(df(), is.numeric, logical(1))
      updateSelectInput(session, "var", choices = names(df())[is_numeric])
    })
    
    reactive(df()[[input$var]])
  })
}

summaryOuput <- function(id) {
  tags$ul(
    tags$li("Min: ", textOutput(NS(id, "min"), inline = TRUE)),
    tags$li("Max: ", textOutput(NS(id, "max"), inline = TRUE)),
    tags$li("Missing: ", textOutput(NS(id, "n_na"), inline = TRUE))
  )
}

summaryServer <- function(id, var) {
  moduleServer(id, function(input, output, session) {
    rng <- reactive({
      req(var())
      range(var(), na.rm = TRUE)
    })
    
    output$min <- renderText(rng()[[1]])
    output$max <- renderText(rng()[[2]])
    output$n_na <- renderText(sum(is.na(var())))
  })
}

ui <- fluidPage(
  selectInput("dfname", "Data frame", choices = c("iris", "mtcars")),
  selectNumericVarInput("var"),
  summaryOuput("summary")
)

server <- function(input, output, session) {
  df <- reactive(switch(input$dfname, 
    mtcars = mtcars,
    iris = iris
  ))
  # Testing
  var <- selectNumericVarServer("var", df)
  summaryServer("summary", var)
}

shinyApp(ui, server)
```




How to return multiple values? Return a list of reactives.

Roxygen documentation conventions are worthwhile even if you don't use roxygen2. Add `@param` and `@returns` arguments to describe exactly how the server component of the module works.

## Reusable components

### Date with error

To convert the code above into a module, we need to make two changes. First we need to add an `id` argument to our UI component, and use it with special `NS()` function. `NS` is short for namespace: it creates a "space" of "names" that is unique to the module. 

First we create the UI. I use the `Input` suffix because from the outside this is about creating an different way of inputing dates; the output is just an implementation detail.

```{r}
ymdDateInput <- function(id, label) {
  label <- paste0(label, " (yyyy-mm-dd)")
  
  fluidRow(
    textInput(NS(id, "date"), label),
    textOutput(NS(id, "error"))
  )
}
```

```{r}
ymdDateServer <- function(id) {
  moduleServer(id, function(input, output, session) {
    date <- reactive({
      req(input$date)
      ymd(input$date, quiet = TRUE)
    })
    
    output$error <- renderText({
      if (is.na(date())) {
        "Please enter valid date in yyyy-mm-dd form"
      }
    })
  
    date
  })
}
```

Now the arguments to `ymdInput()` have changed: we pass in the `id`, and Shiny takes care of automatically plumbing up the input, output, and session in the appropriate namespaced way. That why I've removed the `Server` from the name - since the details are hidden from the interface.

```{r}
ymdDateModule <- function(label) {
  ui <- fluidPage(
    ymdDateInput("ymd", label),
    textOutput("date")
  )
  server <- function(input, output, session) {
    date <- ymdDateServer("ymd")
    output$date <- renderText(date)
  }
}

server <- function(input, output, session) {
  birthday <- ymdDate("birthday")
  
  age <- reactive({
    req(birthday())
    (birthday() %--% today()) %/% years(1)
  })
  
  output$age <- renderText({
    paste0("You are ", age(), " years old")
  })
}
```

To help cement the ideas of modules in your head, the following case studies use module to develop a few simple reusable components.

### Limited selection + other

Consider the following app, which provides a way to select gender that is sensitive to the many possible ways that people can express their gender.[^gender]

[^gender]: For a deeper dive on this issue, and a discussion of why many commonly used way of asking about gender can be hurtful to some people, I recommend reading "Designing forms for gender diversity and inclusion" by Sabrina Fonseca: <https://uxdesign.cc/d8194cf1f51>.

```{r}
ui <- fluidPage(
  radioButtons("gender", "Gender:",
    choiceValues = list("male", "female", "self-described", "na"),
    choiceNames = list(
      "Male",
      "Female",
      textInput("gender_self", NULL, placeholder = "Self-described"),
      "Prefer not to say"
    ),
    selected = "na",
  ),
  textOutput("txt")
)

server <- function(input, output, session) {
  observeEvent(input$gender_self, {
    req(input$gender_self)
    updateRadioButtons(session, "gender", selected = "self-described")
  })
  
  gender <- reactive({
    if (input$gender == "self-described") {
      input$gender_self
    } else {
      input$gender
    }
  })
  
  output$txt <- renderText({
    paste("You chose", gender())
  })
}
```

Convert to a module and generalise a little.

```{r}
radioButtonsExtraUI <- function(id, label, choices, selected = NULL, placeholder = NULL) {
  ns <- NS(id)
  
  radioButtons(ns("primary"), "Gender:",
    choiceValues = c(names(choices), "other"),
    choiceNames = c(
      unname(choices),
      list(textInput(ns("other"), NULL, placeholder = NULL))
    ),
    selected = selected
  )
}

radioButtonsExtraServer <- function(id) {
  moduleServer(id, function(input, output, server) {
    observeEvent(input$primary, {
      req(input$other)
      updateRadioButtons(session, "primary", selected = "other")
    })
    
    reactive({
      if (input$primary == "other") {
        input$other
      } else {
        input$primary
      }
    })
  })
}

ui <- fluidPage(
  radioButtonsExtraUI("gender", 
    label = "Gender", 
    choices = list(
      male = "Male",
      female = "Female",
      na = "Prefer not to say"
    ), 
    placeholder = "Self-described", 
    selected = "na"
  ),
  textOutput("txt")
)

server <- function(input, output, session) {
  gender <- radioButtonsExtraServer("gender")

  output$txt <- renderText({
    paste("You chose", gender())
  })
}
```



## Single object modules

When many people encounter modules for the first time, they immediately attempt to rewrite into a single "thing", a module object that has both UI and server components. If that didn't occur to you, feel free to skip this last part of the chapter, because it explains why that approach (which occurs to many people) isn't a good fit for Shiny.

Shiny explicitly considered and rejected this design because it has some major limitations. For this to work, you have to define the module outside of the server and the UI. That means there's no way to make any of the inputs to the module reactive. 

In Shiny, UI and server are inherently disconnected; Shiny doesn't know which UI invocation belongs to which server session. You can see this pattern throughout Shiny: for example, `plotOutput()` and `renderPlot()` are connected only by shared ID. Writing modules as separate functions reflects that reality: they're distinct functions that are not connected other than through a shared ID.

To illustrate the problem, lets generalise the motivating example from the first part of the chapter so that the data frame is now a parameter:

```{r}
histogramUI <- function(id, df) {
  list(
    selectInput(NS(id, "var"), "Variable", names(df)),
    numericInput(NS(id, "bins"), "bins", 10, min = 1),
    plotOutput(NS(id, "hist"))
  )
}

histogramServer <- function(id, df) {
  moduleServer(id, function(input, output, session) {
    data <- reactive(df[[input$var]])
    output$hist <- renderPlot({
      hist(data(), breaks = input$bins, main = input$var)
    })
  })
}
```

And that leads to the following app:

```{r}
ui <- fluidPage(
  tabsetPanel(
    tabPanel("mtcars", histogramUI("mtcars", mtcars)),
    tabPanel("iris", histogramUI("iris", iris))
  )
)
server <- function(input, output, session) {
  histogramServer("mtcars", mtcars)
  histogramServer("iris", iris)
}
```

It seems undesirable that we have to repeat both the ID and the name of the dataset in both the UI and server, so it's natural to want to wrap into a single function that returns both the UI and the server:

```{r}
histogramModule <- function(id, df) {
  list(
    ui = histogramUI(id, df), 
    server = histogramServer(id, df)
  )
}
```

Then we define the module outside of the UI and server, extracting elements from the list as needed:

```{r, eval = FALSE}
hist1 <- histogramModule("mtcars", mtcars)
hist2 <- histogramModule("iris", iris)

ui <- fluidPage(
  tabsetPanel(
    tabPanel("mtcars", hist1$ui()),
    tabPanel("iris", hist2$ui())
  )
)
server <- function(input, output, session) {
  hist1$server()
  hist2$server()
}
```

There are two problems with this code. Firstly, it doesn't work, because `moduleFunction()` must be called inside a server function. But imagine that problem didn't exist or you worked around it some other way. There's still a big problem: what if we want to allow the user to select the dataset, i.e. we want to make the `df` argument reactive. That can't work because the module is instantiated before the server function, i.e. before we know that information. 

This is fundamentally the way that Shiny works: UI controls and server code are fundamentally de-coupled and only communicated through a shared ID. 

If you find your fingers itching to make a single module object that incorporates both UI and server components it's almost certainly a sign that you've decomposed your repeated code into a module in a suboptimal way.

## Exercises

1. The following app plots user selected variables from the `msleep` dataset 
   for three different types of mammals (carnivores, omnivores, and herbivores), 
   with one tab for each type of mammal. Remove the redundancy in the 
   `selectInput()` definitions with the use of functions.
    
    ```{r, eval = FALSE}
    library(tidyverse)
    
    ui <- fluidPage(
      selectInput(inputId = "x",
                  label = "X-axis:",
                  choices = c("sleep_total", "sleep_rem", "sleep_cycle", 
                              "awake", "brainwt", "bodywt"),
                  selected = "sleep_rem"),
      selectInput(inputId = "y",
                  label = "Y-axis:",
                  choices = c("sleep_total", "sleep_rem", "sleep_cycle", 
                              "awake", "brainwt", "bodywt"),
                  selected = "sleep_total"),
      tabsetPanel(id = "vore",
                  tabPanel("Carnivore",
                           plotOutput("plot_carni")),
                  tabPanel("Omnivore",
                           plotOutput("plot_omni")),
                  tabPanel("Herbivore",
                           plotOutput("plot_herbi")))
    )
    
    server <- function(input, output, session) {
    
      # make subsets
      carni <- reactive( filter(msleep, vore == "carni") )
      omni  <- reactive( filter(msleep, vore == "omni")  )
      herbi <- reactive( filter(msleep, vore == "herbi") )
    
      # make plots
      output$plot_carni <- renderPlot({
        ggplot(data = carni(), aes_string(x = input$x, y = input$y)) +
          geom_point()
      })
      output$plot_omni <- renderPlot({
        ggplot(data = omni(), aes_string(x = input$x, y = input$y)) +
          geom_point()
      })
      output$plot_herbi <- renderPlot({
        ggplot(data = herbi(), aes_string(x = input$x, y = input$y)) +
          geom_point()
      })
    
    }
    
    shinyApp(ui = ui, server = server)
    ```

2. Continue working with the same app from the previous exercise, and further 
   remove redundancy in the code by modularizing how subsets and plots are 
   created.
   
3. Suppose you have an app that is slow to launch when a user visits it. Can  
   modularizing your app code help solve this problem? Explain your reasoning.
