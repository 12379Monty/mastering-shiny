# Reducing duplication with modules {#action-modules}

```{r, include = FALSE}
source("common.R")
```

Before reading chapter make sure that you're already with the previous chapter on using functions to reduce duplication in a Shiny app. Modules provide very similar benefits to functions, but have an explicit connection between ui and server components through **namespacing**.


There are two main reasons to use modules:

*   To isolate subcomponents of your app through specified inputs and outputs.
    This makes it easier to understand how your app works because you don't
    have to load all the pieces into your head to understand how the whole 
    thing hangs together. It also allows you to spread a large app across 
    multiple files.
    
*   To create reusable user interface components that encompass both 
    client-side HTML and server-side behaviour. 

These are not discrete cases, but points of a spectrum:

* No inputs or outputs
* Inputs or outputs
* Inputs and outputs

Often the hardest part is decomposing your big problem into smaller independent pieces. I include some case studies here to help you get a sense of how this feels, but ultimately it's a skill that can only be learned with practice. Try and set aside some time each week where you're not improving the behaviour or appearance of your app, but simply making it easier to understand. This will make your app easier to change in the future, and as you practice these skills your first attempt will become higher quality.

```{r setup}
library(shiny)

# We're experimenting with a new style of module construction that
# will appear in the next version of Shiny.
moduleFunction <- function(id, module) {
  callModule(module, id)
}
```

## What is a module?

A module is just a pair of functions. One function is responsible for generating the UI components; one function is responsible for generating the server side. Both functions take "id" as the first argument, and do something with it. This is the key difference with modules, and is what guarantees their isolation and allows you to use them multiple times in the same app.

Let's take a very simple app and divide it up into module.

```{r}
ui <- fluidPage(
  selectInput("var", "Variable", names(mtcars)),
  numericInput("bins", "bins", 10, min = 1),
  plotOutput("hist")
)
server <- function(input, output, session) {
  data <- reactive(mtcars[[input$var]])
  output$hist <- renderPlot({
    hist(data(), breaks = input$bins, main = input$var)
  })
}
```

```{r}
histogramUi <- function(id) {
  list(
    selectInput(NS(id, "var"), "Variable", names(mtcars)),
    numericInput(NS(id, "bins"), "bins", 10, min = 1),
    plotOutput(NS(id, "hist"))
  )
}
```

```{r}
histogramServer <- function(id) {
  moduleFunction(id, function(input, output, server) {
    data <- reactive(mtcars[[input$var]])
    output$hist <- renderPlot({
      hist(data(), breaks = input$bins, main = input$var)
    })
  })
}
```


```{r}
ui <- fluidPage(
  histogramUi("hist1")
)
server <- function(input, output, session) {
  histogramServer("hist1")
}
```

Two big advantages. Firstly all the code inside the histogram is isolated. The UI below would still work because the histogram module is isolated from the new bins input. You can imagine how helpful this would be when working with large apps!

```{r}
ui <- fluidPage(
  histogramUi("hist1"),
  sliderInput("bins", "bins", 5, min = 1, max = 10)
)
```

The other advantage is that you can easily reuse in multiple places in the app.

```{r}
ui <- fluidPage(
  histogramUi("hist1"),
  histogramUi("hist2")
)
server <- function(input, output, session) {
  histogramServer("hist1")
  histogramServer("hist2")
}
```

### Single function

```{r}
histogramModule <- function(id, df) {
  ui <- function() {
    list(
      selectInput(NS(id, "var"), "Variable", names(df)),
      numericInput(NS(id, "bins"), "bins", 10, min = 1),
      plotOutput(NS(id, "hist"))
    )
  }
  server <- function() {
    moduleFunction(id, function(input, output, server) {
      data <- reactive(df[[input$var]])
      output$hist <- renderPlot({
        hist(data(), breaks = input$bins, main = input$var)
      })
    })
  }
  
  list(ui = ui, server = server)
}

hist1 <- histogramModule("mtcars", mtcars)
hist2 <- histogramModule("iris", iris)

ui <- fluidPage(
  tabsetPanel(
    tabPanel("mtcars", hist1$ui()),
    tabPanel("iris", hist2$ui())
  )
)
server <- function(input, output, session) {
  hist1$server()
  hist2$server()
}
```


## Isolation

Common design for large apps is to arrange independent components with a tabset. This is useful design pattern for the user because it keeps related inputs close to their outputs, reducing the cognitive burden of using the app. Shiny modules allow you to also get the benefits on the backend: you can convert each tab to a separate pair of isolated UI and server functions that live in their own file. This makes your code easier to understand because its now split up across multiple files; each file can be analysed independently, because the outside connections are clearly demarcated.

```{r}
dists <- c(
  "Normal" = "norm",
  "Uniform" = "unif",
  "Log-normal" = "lnorm",
  "Exponential" = "exp"
)

ui <- fluidPage(
  titlePanel("Tabsets"),
  sidebarLayout(
    sidebarPanel(
      radioButtons("dist", "Distribution type:", dists),
      sliderInput("n", "Number of observations:", value = 500, min = 1, max = 1000)
    ),

    mainPanel(
      tabsetPanel(
        tabPanel("Plot", plotOutput("plot")),
        tabPanel("Summary", verbatimTextOutput("summary")),
        tabPanel("Table", tableOutput("table"))
      )
    )
  )
)
```


## Reusable components


## Using modules

A Shiny module is a pair of functions, corresponding to the front end UI and the backend server function. 

Modules are way to create an app within an app. They force isolation of behaviour so that one module can't affect another, and code outside of a module can only affect the inside in a way that the module explicitly allows.

### Making a module

To convert the code above into a module, we need to make two changes. First we need to add an `id` argument to our UI component, and use it with special `NS()` function. `NS` is short for namespace: it creates a "space" of "names" that is unique to the module. 

```{r}
ymdInput <- function(id, label) {
  label <- paste0(label, " (yyyy-mm-dd)")
  
  fluidRow(
    textInput(NS(id, "date"), label),
    textOutput(NS(id, "error"))
  )
}
```

(Notice I've called this `ymdInput()` to match Shiny's existing style.)

The key idea is that the first argument to `NS()` is supplied by the person using the component, and the arguments to the function it produces is supplied by the person who wrote the component. This two-part creation ensures that the final name combines properties needed by both the app author and the module author. This is a bit confusing at first, because you're likely to be both the app and module author.

We now need to specify an `id` when creating the UI. This is important because it puts this id in the same place as all the others, so it's easy to spot if you've used the same input id in multiple places. 

```{r}
ui <- fluidPage(
  ymdInput("birthday", "When were you born?"),
  textOutput("age")
)
```

We need to make a similar change to the server side of the module. Here instead of `NS()` we use `moduleFunction()`. `moduleFunction()` automatically tweaks the `input` and `output` so it looks for `date` inside the `id` namespace. You can think of it as doing `input[[id]]$birthday` (but it's actually `input[[paste(id, "-", birthday)]]`).

```{r}
ymdDate <- function(id) {
  moduleFunction(id, function(input, output, session) {
    date <- reactive({
      req(input$date)
      ymd(input$date, quiet = TRUE)
    })
    
    output$error <- renderText({
      if (is.na(date())) {
        "Please enter valid date in yyyy-mm-dd form"
      }
    })
  
    date
  })
}
```

(One difference with a regular server function is that this function returns a value)

Now the arguments to `ymdInput()` have changed: we pass in the `id`, and Shiny takes care of automatically plumbing up the input, output, and session in the appropriate namespaced way. That why I've removed the `Server` from the name - since the details are hidden from the interface.

```{r}
server <- function(input, output, session) {
  birthday <- ymdDate("birthday")
  
  age <- reactive({
    req(birthday())
    (birthday() %--% today()) %/% years(1)
  })
  
  output$age <- renderText({
    paste0("You are ", age(), " years old")
  })
}
```

To help cement the ideas of modules in your head, the following case studies use module to develop a few simple reusable components.

### Limited selection + other

Consider the following app, which provides a way to select gender that is sensitive to the many possible ways that people can express their gender.[^gender]

[^gender]: For a deeper dive on this issue, and a discussion of why many commonly used way of asking about gender can be hurtful to some people, I recommend reading "Designing forms for gender diversity and inclusion" by Sabrina Fonseca: <https://uxdesign.cc/d8194cf1f51>.

```{r}
ui <- fluidPage(
  radioButtons("gender", "Gender:",
    choiceValues = list("male", "female", "self-described", "na"),
    choiceNames = list(
      "Male",
      "Female",
      textInput("gender_self", NULL, placeholder = "Self-described"),
      "Prefer not to say"
    ),
    selected = "na",
  ),
  textOutput("txt")
)

server <- function(input, output, session) {
  observeEvent(input$gender_self, {
    req(input$gender_self)
    updateRadioButtons(session, "gender", selected = "self-described")
  })
  
  gender <- reactive({
    if (input$gender == "self-described") {
      input$gender_self
    } else {
      input$gender
    }
  })
  
  output$txt <- renderText({
    paste("You chose", gender())
  })
}
```

Convert to a module and generalise a little.

```{r}
radioButtonsExtraUI <- function(id, label, choices, selected = NULL, placeholder = NULL) {
  ns <- NS(id)
  
  radioButtons(ns("primary"), "Gender:",
    choiceValues = c(names(choices), "other"),
    choiceNames = c(
      unname(choices),
      list(textInput(ns("other"), NULL, placeholder = NULL))
    ),
    selected = selected
  )
}

radioButtonsExtraServer <- function(id) {
  moduleFunction(id, function(input, output, server) {
    observeEvent(input$primary, {
      req(input$other)
      updateRadioButtons(session, "primary", selected = "other")
    })
    
    reactive({
      if (input$primary == "other") {
        input$other
      } else {
        input$primary
      }
    })
  })
}

ui <- fluidPage(
  radioButtonsExtraUI("gender", 
    label = "Gender", 
    choices = list(
      male = "Male",
      female = "Female",
      na = "Prefer not to say"
    ), 
    placeholder = "Self-described", 
    selected = "na"
  ),
  textOutput("txt")
)

server <- function(input, output, session) {
  gender <- radioButtonsExtraServer("gender")

  output$txt <- renderText({
    paste("You chose", gender())
  })
}
```

### Hierarchical select boxes

```{r, eval = FALSE}
library(tidyverse)
country_df <- countrycode::codelist %>% 
  as_tibble() %>% 
  select(iso3c, continent, country = cow.name) %>% 
  filter(!is.na(continent), !is.na(country))

continents <- sort(unique(country_df$continent))

ui <- fluidPage(
  selectInput("continent", "Continent", choices = continents),
  selectInput("country", "Country", choices = NULL)
)

server <- function(input, output, session) {
  countries <- reactive({
    country_df[country_df$continent == input$continent, , drop = FALSE]
  })
  
  observeEvent(input$continent, {
    updateSelectInput(session, "country", choice = countries()$country)
  })
}

shinyApp(ui, server)
```

### Modal

<https://gist.github.com/hadley/8d9ee5ea7991b0e5c400320abb9468de>

### Returning multiple reactives

* Leave in a list. 
* Use zeallot

### Exercises

1. The following app plots user selected variables from the `msleep` dataset 
   for three different types of mammals (carnivores, omnivores, and herbivores), 
   with one tab for each type of mammal. Remove the redundancy in the 
   `selectInput()` definitions with the use of functions.

```{r, eval = FALSE}
library(tidyverse)

ui <- fluidPage(
  selectInput(inputId = "x",
              label = "X-axis:",
              choices = c("sleep_total", "sleep_rem", "sleep_cycle", 
                          "awake", "brainwt", "bodywt"),
              selected = "sleep_rem"),
  selectInput(inputId = "y",
              label = "Y-axis:",
              choices = c("sleep_total", "sleep_rem", "sleep_cycle", 
                          "awake", "brainwt", "bodywt"),
              selected = "sleep_total"),
  tabsetPanel(id = "vore",
              tabPanel("Carnivore",
                       plotOutput("plot_carni")),
              tabPanel("Omnivore",
                       plotOutput("plot_omni")),
              tabPanel("Herbivore",
                       plotOutput("plot_herbi")))
)

server <- function(input, output, session) {

  # make subsets
  carni <- reactive( filter(msleep, vore == "carni") )
  omni  <- reactive( filter(msleep, vore == "omni")  )
  herbi <- reactive( filter(msleep, vore == "herbi") )

  # make plots
  output$plot_carni <- renderPlot({
    ggplot(data = carni(), aes_string(x = input$x, y = input$y)) +
      geom_point()
  })
  output$plot_omni <- renderPlot({
    ggplot(data = omni(), aes_string(x = input$x, y = input$y)) +
      geom_point()
  })
  output$plot_herbi <- renderPlot({
    ggplot(data = herbi(), aes_string(x = input$x, y = input$y)) +
      geom_point()
  })

}

shinyApp(ui = ui, server = server)
```

2. Continue working with the same app from the previous exercise, and further 
   remove redundancy in the code by modularizing how subsets and plots are 
   created.
   
3. Suppose you have an app that is slow to launch when a user visits it. Can  
   modularizing your app code help solve this problem? Explain your reasoning.

## Dynamic UI

One extra little trick - you can get the currenct namespace through `session`.
