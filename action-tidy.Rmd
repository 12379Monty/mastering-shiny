# Tidy evaluation {#action-tidy}

```{r, include = FALSE}
source("common.R")
```

If you are using the tidyverse from Shiny, you will almost certainly encounter the challenge of programming with tidy evaluation. Tidy evaluation is the technique that allows you to refer to variables within a data frame, without having to think about it, or do anything special. That's what makes code like this work:

```{r, eval = FALSE}
diamonds %>% filter(x == z)

ggplot(diamonds, aes(x = carat, y = price)) + 
  geom_hex()
```

First we'll go over the basic motivation, and the key idea that makes tidy evaluation more convenient for data analysis and less convenient for programming.

This article will focus on the combination of tidy evaluation with Shiny. If you want to learn more about the general challenges of using tidy evaluation in a package, see
<http://ggplot2.tidyverse.org/dev/articles/ggplot2-in-packages.html> (or the dplyr equivalent, when it exists).

```{r setup}
library(shiny)

data(diamonds, package = "ggplot2")
library(dplyr, warn.conflicts = FALSE)
```

## Motivation

The key idea of tidy evaluation is that it blurs the line between two meaning of "variable":

* Environment variables (env-vars for short), are programming variables. 
  Formally, they are between names and values that are usually created by `<-`.

* Data frame variables (data-vars for short), are "statistical" variables 
  that live inside a data frame. In base R you usually access them with `$` and
  `[[`.
  
Take this piece of code:

```{r}
df <- data.frame(x = runif(3), y = runif(3))
df$x
```

It creates a env-var called `df`, that contains two data-vars `x` and `y`. Then it extracts the data-var `x` out of the data frame `df` using `$`.

Tidy evaluation makes it to write data analysis code because it blurs the distinction between the two. In most (but not all) base R functions you need to refer to a data-variable with `$`, leading to code that repeats the name of the data frame many times:

```{r}
diamonds[diamonds$x == 0 | diamonds$y == 0, ]
```

The dplyr equivalent, `filter()`, uses tidy evaluation to allow you to refer to a data-var as if it was a env-var:

```{r}
filter(diamonds, x == 0 | y == 0)
```

(dplyr's `filter()` is inspired by base R's `subset()`. `subset()` uses an ad hoc approach to each the same reasult as tidy evaluation, so unfortunately the same techniques don't apply to it.)

You usually these verbs purely with data-vars, but they work equally well with env-vars:

```{r}
min_carat <- 1
diamonds %>% filter(carat > min_carat)
```

I think this blurring of the meaning of variable is a really nice feature for interactive data analysis, because it allows you to refer to data-vars as is, without any prefix. And this seems to be fairly intuitive, since many newer R users will attempt to write `diamonds[x == 0 | y == 0, ]`. But when you start to program with these tools, you're going to have to grapple with the distinction. And this will be hard because you've never had to think about it before, so it'll take a while for your brain to learn these new concepts and categories. However, once you've teased apart the idea of "variable" in data-varialbe and env-variable, I think you'll find it fairly easy to use.

### Challenges

When you're programming with env-variables you'll find that tidy evaluation just works:

```{r}
ui <- fluidPage(
  numericInput("min", "min", 1, min = 0, step = 0.1),
  tableOutput("output")
)
server <- function(input, output, session) {
  data <- reactive(filter(diamonds, carat > input$min))
  output$output <- renderTable(head(data()))
}
```

The problem that you will quickly encouter with Shiny is that you want to write code like:

```{r}
ui <- fluidPage(
  selectInput("var", "Variable", choices = names(diamonds)),
  tableOutput("output")
)
server <- function(input, output, session) {
  data <- reactive(filter(diamonds, input$var > 0))
  output$output <- renderTable(head(data()))
}
```

This doesn't work because `input$var` isn't a data-var: it's an env-var containing the name of a data-var (stored as string). Unfortunately it also fails to give a useful error message because `input$var` will be a string like "carat" and:

```{r}
"carat" > 0
```

## User supplied variables

Tidy evaluation solves this conundrum by introducing a special pronoun called `.data`. 

Key challenge is to turn the string giving the name of the variable (e.g. `"cyl"`) into a variable. The way to do that with tidy evaluation is with the special `.data` pronoun.

```{r}
library(ggplot2)

ui <- fluidPage(
  selectInput("x", "X variable", choices = names(iris)),
  selectInput("y", "Y variable", choices = names(iris)),
  plotOutput("plot")
)
server <- function(input, output, session) {
  output$plot <- renderPlot({
    ggplot(iris, aes(.data[[input$x]], .data[[input$y]])) +
      geom_point(position = ggforce::position_auto()) +
      labs(x = input$x, y = input$y)
  })
}
```

I use the special `ggforce::position_auto()` to automatically spread the points out when one axis is discrete. Once you've mastered the basics of tidy evaluation you'll quickly find that the challenge becomes making your app general enough to work with many different types of variable.

### Filtering and arranging

Same idea works for dplyr:

```{r}
library(dplyr, warn.conflicts = FALSE)

ui <- fluidPage(
  selectInput("var", "Select variable", choices = names(mtcars)),
  sliderInput("min", "Minimum value", 0, min = 0, max = 100),
  selectInput("sort", "Sort by", choices = names(mtcars)),
  tableOutput("data")
)
server <- function(input, output, session) {
  observeEvent(input$var, {
    range <- range(mtcars[[input$var]])
    updateSliderInput(session, "min", 
      value = range[[1]], 
      min = range[[1]], 
      max = range[[2]]
    )
  })
  
  output$data <- renderTable({
    mtcars %>% 
      filter(.data[[input$var]] > input$min) %>% 
      arrange(.data[[input$sort]])
  })
}
```

Most other problems can be solved by combining this techique with your existing programming skills. For example, what if you wanted to conditionally sort in either ascending or descending order?

```{r}
ui <- fluidPage(
  selectInput("var", "Sort by", choices = names(mtcars)),
  checkboxInput("desc", "Descending order?"),
  tableOutput("data")
)
server <- function(input, output, session) {
  sorted <- reactive({
    if (input$desc) {
      arrange(mtcars, desc(.data[[input$var]]))
    } else {
      arrange(mtcars, .data[[input$var]])
    }
  })
  output$data <- renderTable(sorted())
}
```

As you provide more control, you'll find the code gets more and more complicated, and it becomes harder and harder to create a user interface that is both comprehensive _and_ user friendly. This is why I've always focussed on code tools for data analysis: creating good UIs is really really hard!

## Selection semantics

Most tidy-evaluation functions have what we call "action" semantics: this means that you can do any calculation inside. Other function have "selection" semantics: you can't do any general computation, but you can select variables using helpers like `starts_with()`, and `ends_with()`. Includes `dplyr::select()`, but also many tidy functions. Note that `group_by()` has action semantics, so you can do (e.g.) `df %>% group_by(x = round(x), y = round(y))`.

Using selection helpers is quite simple: just use `all_of(input$vars)`. The use of `all_of` ensures that they only look in the data frame, not in the environment.

## Multiple variables

There are two ways to select multiple variables. 

```{r}
ui <- fluidPage(
  selectInput("vars", "Variables", names(mtcars), multiple = TRUE),
  tableOutput("count")
)
```

The first approach is to follow the recipe below. Wrap the character vector of variable names in `syms()` and combine it with `!!!`. This approach works due to some deeper tidy eval theory that you probably don't want to care about.

```{r}
server <- function(input, output, session) {
  data <- reactive({
    req(input$vars)
    mtcars %>% group_by(!!!syms(input$vars))
  })
  
  output$count <- renderTable(summarise(data(), n = n()))
}
```

The other approach is to use selection semantics. If the function you're working with uses action semantics, then you can use `across()` to access action semantics. This will be available in dplyr 1.0.0. 

```{r}
server <- function(input, output, session) {
  data <- reactive({
    req(input$vars)
    vars <- one_of(input$vars)
    mtcars %>% group_by(across(vars))
  })
  
  output$count <- renderTable(summarise(data(), n = n()))
}
```

The nice thing about `across()` is that you can use the second argument to transform each column, or you can wrap `across()` to perform some other computation. For example, `df %>% filter(rowSums(across(is.logical) > 0))` would select all rows with at least one true.

## `parse()`

Finally, it's worth a note about using `paste()` + `parse()` + `eval()`.  It's tempting approach because it means that you don't have to learn much new. But it has some major downsides. This is a bad idea because it means that the user of your app can run arbitrary R code. This isn't super important if its a Shiny app that only use you, but it's a good habit to get into --- otherwise it's very easy to accidentally create a security hole in an app that you share more widely.
