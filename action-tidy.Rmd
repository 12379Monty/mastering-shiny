# Tidy evaluation {#action-tidy}

```{r, include = FALSE}
source("common.R")
```

If you are using the tidyverse from Shiny, you will almost certainly encounter the challenge of programming with tidy evaluation. Tidy evaluation is the technique that allows you to refer to variables within a data frame, without having to think about it, or do anything special. That's what makes code like this work:

```{r, eval = FALSE}
diamonds %>% filter(x == z)

ggplot(diamonds, aes(x = carat, y = price)) + 
  geom_hex()
```

First we'll go over the basic motivation, and the key idea that makes tidy evaluation more convenient for data analysis and less convenient for programming, and then we'll talk about the two primary use cases: 

* You want the user to select variables in the app.
* You want to reduce duplication in your app code.

See also <http://ggplot2.tidyverse.org/dev/articles/ggplot2-in-packages.html> (and dplyr equivalent when it exists).

## Motivation

Tidy evaluation works because it allows to avoid to realising that when we say "variable", we're actually talking about two different things:

* Environment variables (or env-vars for short), and "computer science"
  variables that live in environemnts.

* Data frame variables (or df-var for short), are "statistical" variables 
  that live inside a data frame.

Tidy evaluation allows you to write code like this where you refer to the env-var `min_carat` and df-var `carat` in the same way. 

```{r, eval = FALSE}
min_carat <- 1
diamonds %>% filter(carat > min_carat)
```

When you're programming with env-variables you'll find that tidy evaluation just works:

```{r, message = FALSE}
library(dplyr)
diamonds <- ggplot2::diamonds

ui <- fluidPage(
  numericInput("min", "min", 1, min = 0, step = 0.1),
  tableOutput("output")
)
server <- function(input, output, session) {
  data <- reactive({
    arrange(filter(diamonds, carat > input$min), carat)
  })
  output$output <- renderTable(head(data()))
}
```

The problem that you will quickly encouter with Shiny is that you want to write code like:

```{r, eval = FALSE}
diamonds %>% filter(input$var == input$val)

ggplot(diamonds, aes(x = input$x, y = input$y)) + 
  geom_hex()
```

But this doesn't work because dplyr and ggplot2 will attempt to look for a df-variable called `input`, when you want to look for the name of a df-variable stored inside the env-var `input`.

Instead of `object$var`, we're going to use `object[["var"]]`. Because this lets us store the name of a df-variable in a env-variable.

I think the key reason that tidy evaluation is hard to program with, is that it forces you to grapple with this distinction that was previously unimportant. 

## User supplied variables

Key challenge is to turn the string giving the name of the variable (e.g. `"cyl"`) into a variable. The way to do that with tidy evaluation is with the special `.data` pronoun.

```{r}
library(ggplot2)

ui <- fluidPage(
  selectInput("x", "X variable", choices = names(iris)),
  selectInput("y", "Y variable", choices = names(iris)),
  plotOutput("plot")
)
server <- function(input, output, session) {
  output$plot <- renderPlot({
    ggplot(iris, aes(.data[[input$x]], .data[[input$y]])) +
      geom_point(position = ggforce::position_auto()) +
      labs(x = input$x, y = input$y)
  })
}
```

I use the special `ggforce::position_auto()` to automatically spread the points out when one axis is discrete. Once you've mastered the basics of tidy evaluation you'll quickly find that the challenge becomes making your app general enough to work with many different types of variable.

### Filtering and arranging

Same idea works for dplyr:

```{r}
library(dplyr, warn.conflicts = FALSE)

ui <- fluidPage(
  selectInput("var", "Select variable", choices = names(mtcars)),
  sliderInput("min", "Minimum value", 0, min = 0, max = 100),
  selectInput("sort", "Sort by", choices = names(mtcars)),
  tableOutput("data")
)
server <- function(input, output, session) {
  observeEvent(input$var, {
    range <- range(mtcars[[input$var]])
    updateSliderInput(session, "min", 
      value = range[[1]], 
      min = range[[1]], 
      max = range[[2]]
    )
  })
  
  output$data <- renderTable({
    mtcars %>% 
      filter(.data[[input$var]] > input$min) %>% 
      arrange(.data[[input$sort]])
  })
}
```

Most other problems can be solved by combining this techique with your existing programming skills. For example, what if you wanted to conditionally sort in either ascending or descending order?

```{r}
ui <- fluidPage(
  selectInput("var", "Sort by", choices = names(mtcars)),
  checkboxInput("desc", "Descending order?"),
  tableOutput("data")
)
server <- function(input, output, session) {
  sorted <- reactive({
    if (input$desc) {
      arrange(mtcars, desc(.data[[input$var]]))
    } else {
      arrange(mtcars, .data[[input$var]])
    }
  })
  output$data <- renderTable(sorted())
}
```

As you provide more control, you'll find the code gets more and more complicated, and it becomes harder and harder to create a user interface that is both comprehensive _and_ user friendly. This is why I've always focussed on code tools for data analysis: creating good UIs is really really hard!

### Selection semantics

Most tidy-evaluation functions have what we call "action" semantics: this means that you can do any calculation inside. Other function have "selection" semantics: you can't do any general computation, but you can select variables using helpers like `starts_with()`, and `ends_with()`. Includes `dplyr::select()`, but also many tidy functions. Note that `group_by()` has action semantics, so you can do (e.g.) `df %>% group_by(x = round(x), y = round(y))`.

Using selection helpers is quite simple: just use `all_of(input$vars)`. The use of `all_of` ensures that they only look in the data frame, not in the environment.

### Multiple variables

There are two ways to select multiple variables. 

```{r}
ui <- fluidPage(
  selectInput("vars", "Variables", names(mtcars), multiple = TRUE),
  tableOutput("count")
)
```

The first approach is to follow the recipe below. Wrap the character vector of variable names in `syms()` and combine it with `!!!`. This approach works due to some deeper tidy eval theory that you probably don't want to care about.

```{r}
server <- function(input, output, session) {
  data <- reactive({
    req(input$vars)
    mtcars %>% group_by(!!!syms(input$vars))
  })
  
  output$count <- renderTable(summarise(data(), n = n()))
}
```

The other approach is to use selection semantics. If the function you're working with uses action semantics, then you can use `across()` to access action semantics. This will be available in dplyr 1.0.0. 

```{r}
server <- function(input, output, session) {
  data <- reactive({
    req(input$vars)
    vars <- one_of(input$vars)
    mtcars %>% group_by(across(vars))
  })
  
  output$count <- renderTable(summarise(data(), n = n()))
}
```

The nice thing about `across()` is that you can use the second argument to transform each column, or you can wrap `across()` to perform some other computation. For example, `df %>% filter(rowSums(across(is.logical) > 0))` would select all rows with at least one true.

## Reducing duplication

Another way you might want to use tidy evaluation is to reduce duplication. This is not directly related to Shiny, but it's a useful technique that crops up a lot when making more complex apps.

For example, in our example in Section \@ref(hierarchical-select), we did some copying and pasting to produce a series of filtered datasets:

```{r, eval = FALSE}
territory <- reactive({
  req(input$territory)
  filter(sales, TERRITORY == input$territory)
})
customer <- reactive({
  req(input$customername)
  filter(territory(), CUSTOMERNAME == input$customername)
})
order <- reactive({
  req(input$ordernumber)
  filter(customer(), ORDERNUMBER == input$ordernumber)
})
```

```{r, eval = FALSE}
filter_by_var <- function(data, input, var) {
  reactive({
    req(input[[var]])
    filter(data, .data[[toupper(var)]] == input[[var]])
  })
}

order <- filter_by_var(sales(), input, "territory")
customer <- filter_by_var(order(), input, "customer")
order <- filter_by_var(customer(), input, "ordernumber")
```

Key idea is that `input` is a list, and as well as accessing components directly with `$`, we can also access them indirectly with `[[`.

## `parse()`

Finally, it's worth a note about using `paste()` + `parse()` + `eval()`.  It's tempting approach because it means that you don't have to learn much new. But it has some major downsides. This is a bad idea because it means that the user of your app can run arbitrary R code. This isn't super important if its a Shiny app that only use you, but it's a good habit to get into --- otherwise it's very easy to accidentally create a security hole in an app that you share more widely.
