# Understanding reactive programming {#reactivity-mental-model}

```{r setup, include=FALSE}
source("common.R")
```

## Introduction

In this chapter, we'll form a mental model of reactive programming. Without reactive programming, Shiny would not exist, and in well-informed hands it is by far the most elegant, robust, and productive way we know of for creating dynamic user interfaces.

With traditional object-oriented UI programming, an inordinate amount of effort and complexity comes from explicitly managing the relationships between different pieces of UI, and updating the cascading sets of variables that depend on the UI and on each other. We want our code to be fast, correct, and easy to write/maintain. But when creating complex interactive data displays using traditional techniques, we're lucky to achieve even two out of those three. 

In contrast, with just reactive inputs/values, reactive expressions, and observers/outputs, we have a rich vocabulary for expressing calculations and outputs, and that forms the foundation for a better way to do UI programming. As long as we can break up our logic into distinct-but-related calculations, actions, and outputs, Shiny's reactive framework will automatically handle the tedious and error-prone task of deciding what pieces need to be updated, and when.

The biggest drawback of reactive programming is that it is not intuitive--at first. Even experienced R users can have trouble getting their heads around reactive programming as they get started with Shiny, and those with deep experience in software engineering may feel uncomfortable with a programming paradigm with so much "magic". But once you've formed an accurate mental model, you'll see that reactive programming is built on simple concepts and mechanisms that you can easily reason about.

## Why reactive programming? {#motivation}

Reactive programming is primarily a style of programming that emphasizes _values that change over time_, and _calculations and actions that depend on those values_. To put it concretely, Shiny apps are interactive: users change input controls (sliders, textboxes, checkboxes), which causes logic to run on the server (reading CSVs or performing database queries, subsetting data, running simulations or models), ultimately resulting in outputs updating (plots, tables, blocks of text, downloadable PDFs). For Shiny apps to be useful, we need two things:

* Every time an input changes, automatically re-run all expressions and outputs
  that depend on that value. This ensures that 
  
* Conversely, for Shiny apps to respond quickly to user input, it's important 
  that _only_ the relevant logic runs, and _only_ the affected outputs update. 
  It'd be a frustratingly poor user experience if, say, changing a plot y-axis 
  from linear to log scale caused the expensive logic behind a totally 
  unrelated summary table to be rerun.

To see how reactive programming solve these problems, lets take it back to a very simple example, eliminating all additional complexity of a web app, and focussing on the underlying code.

### Why can't you use variables?

In one sense, all programmers are used to "values that change over time": they're called "variables", right? Yes, variables in R represent values and they can change over time. But they're not particularly designed to help you when their values change.

```{r}
temp_celsius <- 10
is_freezing <- temp_celsius <= 0
is_freezing
```

So far so good: the `temp_celsius` variable has the value `10`, and the `is_freezing` variable has the value `TRUE`. But if you change `temp_celsius`, then `is_freezing` does not update:

```{r}
temp_celsius <- -3
is_freezing
```

### What about functions?

You could instead attack this problem by using functions:

```{r}
temp_celsius <- 10
is_freezing <- function() {
  message("Computing freezing point") 
  temp_celsius <= 0
}
is_freezing()

temp_celsius <- -3
is_freezing() 
```

This solves the first problem that reactivity is trying to solve: whenever you access `is_freezing()` you get the latest computation. It doesn't, however solve the second problem of trying to do as little computation as possible because every time you call `is_freezing()` it recomputes:

```{r}
is_freezing() 
```

That isn't a problem here, but in real apps, this would add substantial cognitivie overhead: you'd constantly need to be thinking about how to minimise computation.

### Event-driven programming {#event-driven}

In decades past, there wouldn't even be a question about how such interactive user interfaces would be written: _event-driven programming_ was the only game in town. It's an appealingly simple paradigm: you register callback functions to be executed in response to events (e.g. a mouse click, or a textbox's value being changed). Had Shiny been invented five years earlier, the code above might have looked like this:

```{r, eval = FALSE}
temp_celsius <- dynamic_value(10)

temp_celsius$onUpdate({
  message("Computing freezing point") 
  is_freezing <<- temp_celsius$get() <= 0
})

is_freezing
#> [1] FALSE

temp_celsius$set(-3)
is_freezing
#> [1] TRUE
```

Note that we can no longer rely on an ordinary variable, and instead have to create an (imaginary) `dynamic_value`. This object has three important methods: `get()` and `set()` allows you access and change the underlying value, while `onUpdate()` lets you run code every time the value changes. Here we're using `<<-` to update the value of `is_freezing` in the global environment every time the temperature changes.

Unfortunately, this kind of programming is _simple_, not _easy_! As your application adds more features, it becomes very difficult to keep track of what inputs affect what calculations, and what calculations affect each other, and what input and calculations affect what outputs and actions. Before long, you start to trade off correctness (just update everything whenever anything changes) against performance (try to update only the necessary parts, and pray you didn't miss any edge cases), because it's so difficult to optimize for both.

### Reactive programming

Reactive programming elegantly solves both problems by combining features of each of the solutions above. Now we can show you some real Shiny code. We're going to do this using a special Shiny mode, enabling the reactive console so you that you can experiment directly with reactivity outside of an app. This mode is usually disabled because it makes a certain class of problems harder to spot in apps, and it's not worth enabling because its primary use is for understand reactivity; it's not otherwise useful tool.

```{r, cache = FALSE}
library(shiny)
consoleReactive(TRUE)
```

Like the event-driven programming example, we still need some way to indicate that we have a special dynamic variable. In Shiny that function is `reactiveVal()`. It creates a __reactive value__ that behaves specially. You can retrieve it's current value by calling like a function, and you can set it's value by calling it with a single argument:

```{r}
temp_celsius <- reactiveVal(10)
temp_celsius()
temp_celsius(20)
temp_celsius()
```

Now we can create a reactive expression that depends on this value. A reactive expression automatically tracks all of its dependencies:

```{r}
is_freezing <- reactive({
  message("Computing freezing point") 
  temp_celsius() <= 0
})
is_freezing()
```

So that later if `temp_celsius` changes, `is_freezing()` will be up to date:

```{r}
temp_celsius(-3)
is_freezing()
```

Importantly, note accessing it again does not trigger recomputation. It's this property that ensures Shiny apps do as little work as possible.

```{r}
is_freezing()
```

In the next chapter you'll learn precisely how this dependency tracking works.

## Reactive programming in Javascript

Reactive programming roared into the programming mainstream in the 2010s, via the blisteringly fast-paced world of JavaScript UI frameworks. Pioneering frameworks like [Knockout](https://knockoutjs.com/), [Ember](https://emberjs.com/), and (Joe Cheng's personal inspiration) Meteor demonstrated that reactive programming could make UI programming dramatically easier. Within a few short years, reactive programming has come to dominate UI programming on the web, with hugely popular frameworks like React, Vue.js, and Angular that are either inherently reactive or designed to work with reactive backends.

Before we go further, please be aware that the term "reactive programming" is a fairly general term in the programming world. While all reactive programming libraries/frameworks/languages are broadly about writing programs that respond to changing values, they vary enormously in their terminology, designs, and implementations.

In this book, whenever we refer to "reactive programming", we are referring specifically to reactive programming as implemented in Shiny. Conversely, if you read any material about reactive programming that isn't specifically about Shiny, it's unlikely that those concepts or even terminology will be relevant to writing Shiny apps. For readers who do have some experience with other reactive programming frameworks, our approach is similar to [Meteor](https://www.meteor.com/) and [MobX](https://mobx.js.org/), and very different than the [ReactiveX](http://reactivex.io/) family or anything that labels itself Functional Reactive Programming (often called FRP for short).

## Reactive building blocks {#primitives}

While there are lots of reactive programming related functions in Shiny, there are three objects that almost all of them build on, both conceptually and literally. We call these _reactive primitives_ because they are a fundamental part of the reactive framework and, unlike many of the other reactive objects that we'll eventually cover, could not possibly be implemented outside of the framework itself.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/producers-consumers.png", dpi = 300)
```

We'll go through these one by one, though not in that order; instead, we'll start by talking about reactive values, jump ahead to observers, then talk about reactive expressions. We'll finsh up by discussing reactive outputs 

For the remainder of the chapter I'll be running with a reactive console, so if you're following along on your own computer, you'll need to enable that too:

```{r}
consoleReactive(TRUE)
```

### Reactive values: values that change over time

Before we start talking about reactive values, one pedagogically awkward little wrinkle is that reactive values come in three different flavors: inputs, `reactiveValues()`, and `reactiveVal()`. These three types are conceptually identical, but their implementations are slightly different.

```{r}
val <- reactiveVal()
vals <- reactiveValues()
```

Inputs are by far the most common type of reactive value. You've already seen the `input` object, which is provided as an argument to your Shiny app's server function. It represents the collective input received from your app's user interface, and you access individual input values from it with the same operators you'd use for a named list, e.g. `input$x` or `input[["x"]]` for an input named `x`. The values in `input` change whenever something happens in the user interface. Because `input` is intended to be a reflection of the state of the user interface, you can read from it but you can't write to it.

Don't be fooled, though: while `input$x` looks like reading a normal value from a normal list, there's something very important going on under the hood. In order to understand what that is, we need to talk about who is doing the reading.

Generally, R functions and variables are totally agnostic to, and in fact ignorant of, who/what is calling or reading them. When an R function is invoked, it runs and returns a value. When a variable is read, it doesn't matter to the variable why that read is happening. In reactive programming, the situation is very different.

If a read of a regular variable is asking "What's the value of `x`?", reading a reactive value is asking "What's the value of `input$x`? **And please notify me the next time `input$x` changes!**" In other words, a reactive read has implications for both _now_ (returns the current value) and _later_ (notifies of the next change to the value).

Because reactive reads have this additional "later" effect, the `input` object is very selective about who is allowed to access its data. Attempting to read `input$x` from anywhere but a bona fide reactive object, like a reactive expression or observer, throws an error. The actual text of this error is "Operation not allowed without an active reactive context", and it essentially means "I won't talk to you unless you give me a way to notify you that `input$x` changed".

Now let's shift gears and talk about the objects that _can_ read reactive values, and what will happen when they're notified of changes in `input$x`.

There are two fundamental types of reactive consumers in Shiny. One type is for actions (with side effects), the other is for calculations (no side effects).

### Detour: Side-effects

Before we talk about the difference between reactive expressions and observers we need to talk about side-effects. You can think of all R functions as falling into one of two categories:

1. **Functions that are only interesting for the result that they return**, 
    e.g. `c()`, `list()`, `lm()`, `predict()`, `read.csv()`, `ls()`.
    
2.  **Functions that perform some kind of action** (besides calculating a 
    result), e.g. `print()`, `plot()`, `write.csv()`, `rm()`, 
    `install.packages()`.

_Side effects_ are what we call the kinds of actions in the second category. Unlike with pharmaceuticals, where side effects are always unintentional and usually negative, we simply mean any effects apart from a function's return value. Changing a file on disk is a side effect. Printing words to the console is a side effect. Sending a message to another computer is a side effect.

As a shorthand, you can think of functions without side effects as _calculations_, and functions with side effects as _actions_. Some functions calculate a value; other functions perform an action. (Some functions do both, and they are often frustrating because of it)

As we learn to write more complicated Shiny apps, it's important to think about your code in terms of calculations and actions. Shiny has opinions about what reactive abstractions you should use to wrap each kind of code, and if you structure your app in accordance with those opinions you'll end up with code that's more reliable, better performing, and easier to maintain.

### Observers: Actions that execute automatically

_Observers_ are one type of reactive consumer. An observer takes a code block that performs an action of some kind. Here's an observer that prints the value of `x` every time it changes:

```{r}
x <- reactiveVal(10)
observe({
  message("`x` is ", x())
})

x(5)
x(10)
```

This code block does three things:

1. Prints out the message `"We're about to print x:"`
2. Prints the value of `input$x`
3. Subscribes to be notified of the next change to `input$x` 
   (this subscription happens automatically, just by reading `input$x`)

When `input$x` changes, and this observer is notified, it requests that the Shiny runtime run its code block again, and the three steps above will repeat. Observers are reactive consumers because they know how to respond to one of their dependencies changed: they re-run their code block.

Observers aren't limited to reading a single reactive value; each observer can read zero, one, or multiple reactive values. 

### Reactive expressions: Smart calculations

_Reactive expressions_ are the other fundamental type of reactive consumer. While observers model actions that have side effects, reactive expressions model calculations that return values. (There's nothing that prevents you from putting side effects in your reactive expressions, but it's generally a bad idea.)

Here's a very simple reactive expression named `up_to_x` that generates a sequence of numbers based on `input$x`. (If you're not familiar with `seq_len`, it simply returns a sequence of increasing numbers starting from 1 to whatever number you pass it; for example, `seq_len(3)` returns `c(1L, 2L, 3L)`.)

```{r}
up_to_x <- reactive({
  seq_len(x())
})
```

The mere act of creating this reactive expression doesn't cause any code to execute. Rather, it just means that this sequence of numbers is available for retrieval, by calling `up_to_x()` like its a function. In this sense, creating a reactive expression is like to declaring an R function: nothing actually happens until you call it.

In the following snippet, the code contained in `up_to_x` (from the above snippet) is not executed until the line `print(up_to_x())` is reached, as this is the first time the result of `up_to_x` is actually requested. (Because of this property, we say that reactive expressions are _lazy_ as opposed to _eager_.)

```{r}
observe({
  print(up_to_x())
})

x(4)
```

This observer prints the sequence to the console whenever `up_to_x` changes (i.e. whenever `input$x` changes, because `up_to_x` reads `input$x`).

Just like with reading reactive values, reactive expressions are only readable by reactivity-aware consumers, and for the same reason: because `up_to_x()` is more than just "Can you calculate the current value of `up_to_x`?"; instead, it's "Can you calculate the current value of `up_to_x`? _And also notify me if something about this sequence changes?_"

So far we've learned that reactive expressions are _reactive_: they know when the reactive values they've read have changed, and they alert their readers when their own value may have changed. They're also _lazy_: they contain code, but that code doesn't execute unless/until someone tries to actually retrieve the value of the reactive expression (by calling it like a function).

The final important property of reactive expressions is that they _cache_ their most recent value. If you're not familiar with the term "cache", it means keeping a previously retrieved (or in this case, calculated) result in hand so that it can be used to satisfy future requests.

The first time a reactive expression is called, it will execute its code body, and depending on what that code does, it might take a significant amount of time. But when the calculation is complete, the resulting value will be both returned to the caller _and_ remembered by the reactive expression. Subsequent calls to the reactive expression take essentially no time at all, as the saved value can be returned instantly. If a reactive expression depends on reactive values or expressions, then any changes to those will cause the cached value to be discarded. When that happens, the next call to the reactive expression will again cause an actual calculation, whose result will then be saved for subsequent calls.

These particular properties--laziness, caching, reactivity, and lack of side effects--combine to give us an elegant and versatile building block for reactive programming.

### Outputs

You may wonder how Shiny outputs fit into this picture. By outputs, I'm referring to code like this:

```{r eval=FALSE}
output$text <- renderText({
  paste(up_to_x(), collapse = ", ")
})
```

Is this an observer or a reactive expression? It looks like a reactive expression because we're doing something with the result of `renderText()`, but as you've seen previously, `output` is write-only: you can't retrieve the value.

The answer is neither, per se. Reactive expressions and observers (and reactive values) are _primitives_ of reactive programming, meaning, they are fundamental building blocks. Outputs, on the other hand, are a feature of Shiny that is built on top of those reactive primitives. The details of how they are implemented are not that important, but it is important to know their characteristics.

Most importantly, outputs are reactive consumers. Output code is allowed to read reactive values like `input$x` or reactive expressions like `up_to_x()`, and the output will know when those reactive dependencies change.

Whereas observers execute eagerly and reactive expressions execute lazily, outputs are somewhere in between. When an output's corresponding UI element is visible in the browser, outputs execute eagerly; that is, once at startup, and once anytime their relevant inputs or reactive expressions change. However, if their UI element becomes hidden (e.g. it is located on a `tabPanel` that is not active, or `removeUI` is called to actively remove it from the page) then Shiny will automatically suspend (pause) that output from reactively executing. (In rare cases, you may prefer to process even outputs that aren't hidden. You can use the `outputOptions()` function's `suspendWhenHidden` to opt out of the automatic suspension feature on an output-by-output basis.)

We also know that observers should be used for side effects (actions), and reactive expressions for their return values (calculations). Again, outputs are somewhere in between. Depending on the `renderXXX` function you use to wrap it, your render code block may need to return a value and/or perform a side effect. For example, `renderText` expects you to return a string, while `renderPrint` expects you to make calls to `print()`; and `renderPlot` expects you to either draw a plot to the active graphics device or return a plottable object (like a ggplot2 object).

Though outputs allow (and may even require) side effects, this doesn't mean you should include just any side effects in your output code. Shiny assumes that the whole code block of an output exists only in service of populating that output. If your output code block contains logic whose side effects are important for reasons apart from the actual output, you should extract that logic into a separate observer. That way, you can be confident it will execute regardless of whether the output is visible or not, now or in the future.

