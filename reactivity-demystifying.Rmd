# Understanding reactivity {#reactivity-mental-model}

```{r setup, include=FALSE}
source("common.R")
```

## Introduction

The initial impression of Shiny is often that it's "magic". This is great when you get started because you can make simple apps very very quickly. But magic in software usually leads to disillusionment. Without a solid mental model to reason with, it's extremely difficult to predict how the software will act when you venture beyond the borders of its demos and examples. And when things don't go the way you expect, debugging is almost impossible.

Fortunately shiny is "good" magic. As Tom Dale said of his Ember.js JavaScript framework: "We do a lot of magic, but it's _good magic_, which means it decomposes into sane primitives." This is the quality we aspire to for Shiny, especially when it comes to reactive programming. When you peel back the layers of reactive programming, you won't find a pile of heuristics, special cases, and hacks; but rather, a clever but ultimately fairly straightforward mechanism.

In this chapter, we'll talk about why reactive programming is so important, a little bit about it's recent history, and start to discuss the underlying data structures that allows Shiny to implement it.

## Why reactive programming? {#motivation}

Reactive programming is a style of programming that emphasizes values that change over time, and calculations and actions that depend on those values. 

Shiny apps are interactive: users change input controls (sliders, textboxes, checkboxes), which causes logic to run on the server (reading CSVs or performing database queries, subsetting data, running simulations or models), ultimately resulting in outputs updating (plots, tables, blocks of text, downloadable PDFs). For Shiny apps to be useful, we need two things:

* To ensure that input and output stay in sync, all expressions and outputs 
  that depend on an input value must be automatically updated every time it
  changes.
  
* To ensure that apps respond quickly to user input, _only_ the relevant 
  expressions should run, and _only_ the affected outputs should update. It'd 
  be a frustrating experience if, say, changing a plot y-axis from linear to 
  log scale caused the expensive logic behind a totally unrelated summary 
  table to be rerun.

It's relatively easy to satisify one of the two conditions, but much harder to satisfy both. To see why, and to see how we might attack the basic problem with other styles of programming lets take it back to a very simple example, eliminating all additional complexity of a web app, and focussing on the underlying code.

### Why can't you use variables?

In one sense, all programmers are used to "values that change over time": they're called "variables". And yes, variables in R represent values and they can change over time. But they're not particularly designed to help you when their values change. Take this simple example of converting a temperature in Celsius to Fahrentheit:

```{r}
temp_c <- 10
temp_f <- (temp_c + 32) * 9 / 5 
temp_f
```

So far so good: the `temp_c` variable has the value `10`, and the `temp_f` variable has the value 75.6. But changing `temp_c` does not affect `temp_f`:

```{r}
temp_c <- 30
temp_f
```

Variables can change over time, but they never change automatically as 

### What about functions?

You could instead attack this problem with a function:

```{r}
temp_c <- 10
temp_f <- function() {
  message("Converting") 
  (temp_c + 32) * 9 / 5 
}
temp_f()

temp_celsius <- -3
temp_f() 
```

(This is a slightly weird function because it doesn't have any arguments, but instead accesses `temp_c` from its enclosing environment, but it's perfectly valid R code.)

This solves the first problem that reactivity is trying to solve: whenever you access `temp_f()` you get the latest computation. It doesn't, however solve the second problem of trying to do as little computation as possible. Every time you call `temp_f()` it recomputes:

```{r}
temp_f() 
```

That isn't a problem here in this trivial example, but minimising recomputation is a substantial challenge in real apps.

### Event-driven programming {#event-driven}

Since neither of the built-in tools of variables or functions work, we have to create something new. In previous decades, there wouldn't have been any question about what we should add: we'd implement something to support _event-driven programming_. It's an appealingly simple paradigm: you register callback functions to be executed in response to events (e.g. a mouse click, or a textbox's value being changed). 

```{r, echo = FALSE}
DynamicValue <- R6::R6Class("DynamicValue", list(
  value = NULL,
  on_update = NULL,
  get = function() self$value,
  set = function(value) {
    self$value <- value
    if (!is.null(self$on_update)) 
      self$on_update()
    invisible(self)
  },
  onUpdate = function(action) {
    self$on_update <- rlang::as_function(rlang::enquo(action))
    invisible(self)
  }
))
```

Had Shiny been invented five years earlier, we might have written something like this:

```{r}
temp_c <- DynamicValue$new()
temp_c$onUpdate({
  message("Converting") 
  temp_f <<- (temp_c$get() + 32) * 9 / 5 
})

temp_c$set(10)
temp_f

temp_c$set(-3)
temp_f
```

Note that we can no longer rely on an ordinary variable, and instead have to create an (imaginary) `DynamicValue`. This object has three important methods: `get()` and `set()` to access and change the underlying value, and `onUpdate()` lets you register code to run every time the value is modified. Here we're using `<<-` to update the value of `temp_f()` in the global environment every time the temperature changes.

Unfortunately, this kind of programming is _simple_, not _easy_! As your application adds more features, it becomes very difficult to keep track of what inputs affect what calculations, and what calculations affect each other, and what input and calculations affect what outputs and actions. Before long, you start to trade off correctness (just update everything whenever anything changes) against performance (try to update only the necessary parts, and pray you didn't miss any edge cases), because it's so difficult to optimize for both.

### Reactive programming

Reactive programming elegantly solves both problems by combining features of each of the solutions above. Now we can show you some real Shiny code. We're going to do this using a special Shiny mode, `consoleReactive(TRUE)`, enabling reactivity in the console so you that you can experiment with it directly, outside of an app. This mode is isn't enabled by default because it makes a certain class of bug harder to spot in an app, and it's primary benefit is to help you understand reactivity.

```{r, cache = FALSE}
library(shiny)
consoleReactive(TRUE)
```

As with event-driven programming, we still need some way to indicate that we have a special dynamic variable: `shiny::reactiveVal()`. This creates a single __reactive value__ that has a special syntax for getting and setting its value[^mutable-cell]. You use it much like a reactive expression, but it has the additional property that you can set its value.

[^mutable-cell]: If you've programmed in languages like rust or clojure this might look familiar: this is very similar to a mutable cell.

```{r}
temp_c <- reactiveVal(10)
temp_c()   # get
temp_c(20) # set
temp_c()   # get
```

Now we can create a reactive expression that depends on this value. As you've seen previously, a reactive expression automatically tracks all of its dependencies:

```{r}
temp_f <- reactive({
  message("Converting") 
  (temp_c() + 32) * 9 / 5 
})
temp_f()
```

So that later if `temp_celsius` changes, `is_freezing()` will be up to date:

```{r}
temp_c(-3)
temp_f()
temp_f()
```

Notice that the conversion only happens if we request the value of `temp_f()`, and the computation happens only once. Shiny strives to be as lazy as possible! In the next chapter you'll learn precisely how this dependency tracking works.

## A brief history of reactive programming 

<!--
https://www.cocoawithlove.com/blog/reactive-programming-what-and-why.html#appendix-a-little-bit-of-history
-->

The chances are you've already actually done a bunch of reactive programming outside of R already: 

Spreadsheets. Original and most popular instantiation of reactivity. When you update a cell all of it dependencies automatically update.

FRP, 1997. Mostly of research interest.

Reactive programming roared into the programming mainstream in the 2010s, via the blisteringly fast-paced world of JavaScript UI frameworks. Pioneering frameworks like [Knockout](https://knockoutjs.com/), [Ember](https://emberjs.com/), and (Joe Cheng's personal inspiration) Meteor demonstrated that reactive programming could make UI programming dramatically easier. Within a few short years, reactive programming has come to dominate UI programming on the web, with hugely popular frameworks like React, Vue.js, and Angular that are either inherently reactive or designed to work with reactive backends.

Before we go further, please be aware that the term "reactive programming" is a fairly general term in the programming world. While all reactive programming libraries/frameworks/languages are broadly about writing programs that respond to changing values, they vary enormously in their terminology, designs, and implementations.

In this book, whenever we refer to "reactive programming", we are referring specifically to reactive programming as implemented in Shiny. Conversely, if you read any material about reactive programming that isn't specifically about Shiny, it's unlikely that those concepts or even terminology will be relevant to writing Shiny apps. For readers who do have some experience with other reactive programming frameworks, our approach is similar to [Meteor](https://www.meteor.com/) and [MobX](https://mobx.js.org/), and very different than the [ReactiveX](http://reactivex.io/) family or anything that labels itself Functional Reactive Programming (often called FRP for short).

## Reactive building blocks {#primitives}

While there are lots of reactive programming related functions in Shiny, there are three objects that almost all of them build on, both conceptually and literally. We call these __reactive primitives__ because they are a fundamental part of the reactive framework and, unlike many of the other reactive objects that we'll eventually cover, could not possibly be implemented outside of the framework itself.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/basic-reactivity/producers-consumers.png", dpi = 300)
```

I assume that you're already familiar with the basic operation of these components. 

We'll start by talking about reactive values, jump ahead to observers, then talk about reactive expressions. We'll finsh up by discussing reactive outputs, which are a special type of observer.

For the remainder of the chapter I'll be running with a reactive console, so if you're following along on your own computer, you'll need to enable that too:

```{r}
consoleReactive(TRUE)
```

### Reactive values: values that change over time

As we saw above, shiny provides a special syntax for reactive values, because we need some way to update them over time. As you saw above, `reactiveVal()` allows you to do this for a single value:

```{r}
val <- reactiveVal(10)

# Set
val(20)
# Get
val()
```

This is paired with `reactiveValues()` which allows you to work with multiple reactive values, as if you have a list.

```{r}
vals <- reactiveValues(x = 1, y = 2)

# Set
vals$y <- 100
# Get
vals$x
```

Finally the `input` that your server function gets is also a list of reactive values. It's special because it's read-only to you. Only Shiny can update this list because it's in charge of sending the values from the browser to R.

Inputs are by far the most common type of reactive value. You've already seen the `input` object, which is provided as an argument to your Shiny app's server function. It represents the collective input received from your app's user interface, and you access individual input values from it with the same operators you'd use for a named list, e.g. `input$x` or `input[["x"]]` for an input named `x`. The values in `input` change whenever something happens in the user interface. Because `input` is intended to be a reflection of the state of the user interface, you can read from it but you can't writ? to it.

Generally, you don't need to use `reactiveValues()` yourself. But then can be useful for achieving specific types of coordination that would otherwise be inaccessible, particularly maintaining state. You need to be extra careful when reading to and writing from `reactiveValues()` because unlike the rest of Shiny, there's nothing to stop you from getting caught in an infinite loop.

```{r}
count <- function(signal) {
  val <- reactiveVal(0)
  
  observeEvent(signal(), {
    val(val() + 1)
  })

  reactive(val())
}
```

The big difference between reactive values and ordinary R values is that reactive values tracks who accesses them. And then when the value changes, it automatically lets everyone know that there's been a change. If a read of a regular variable is asking "What's the value of `x`?", reading a reactive value is asking "What's the value of `input$x`? **And please notify me the next time `input$x` changes!**" In other words, a reactive read has implications for both _now_ (returns the current value) and _later_ (notifies of the next change to the value).

We'll come back to that in detail in Chapter \@ref(dependency-tracking).

Now let's shift gears and talk about the objects that _can_ read reactive values, and what will happen when they're notified of changes in `input$x`. There are two fundamental types of reactive consumers in Shiny. One type is for actions (with side effects), the other is for calculations (no side effects).

:::sidebar
Almost all R functions are either __calculations__ or __actions__:

1. Calculation return a value: e.g. `sum()`, `mean()`, `read.csv()`.
1. Actions change the world in some way: e.g. `print()`, `plot()`, `write.csv()`.

In programming terminology, changing the world is called a __side-effect__. Unlike pharmaceuticalswhere side effects are always unintentional and usually negative, we simply mean any effects apart from a function's return value. Changing a file on disk is a side effect. Printing words to the console is a side effect. Sending a message to another computer is a side effect.

:::

### Observers: Automatic actions

Observers are reactive consumer that takes a code block that performs an action of some kind. Observers are reactive consumers because they know how to respond to one of their dependencies changed: they re-run their code block. Here's an observer that prints the value of `x` every time it changes:

```{r}
x <- reactiveVal(10)
observe({
  message("`x` is ", x())
})

x(5)
x(10)
```

This observer does two things. It prints out a message giving the current value of x, _and_ it subscribes to be notified of the next change to `x()`. When `x` changes, and this observer is notified, it requests that the Shiny runtime run its code block again, and two steps repeat. 

It's important to understand that the subscription is not permanent, but happens multiple times, and it happens dynamically. That means that you can conditionally subscribe. TODO: Add example.

Observers aren't limited to reading a single reactive value; each observer can read zero, one, or multiple reactive values. 

### Reactive expressions: Smart calculations

Reactive expressions are the other fundamental type of reactive consumer. While observers model actions that have side effects, reactive expressions model calculations that return values. (There's nothing that prevents you from putting side effects in your reactive expressions, but it's generally a bad idea.)

Here's a very simple reactive expression named `up_to_x` that generates a sequence of numbers based on `input$x`. (If you're not familiar with `seq_len`, it simply returns a sequence of increasing numbers starting from 1 to whatever number you pass it; for example, `seq_len(3)` returns `c(1L, 2L, 3L)`.)

```{r}
up_to_x <- reactive({
  seq_len(x())
})
```

The mere act of creating this reactive expression doesn't cause any code to execute. Rather, it just means that this sequence of numbers is available for retrieval, by calling `up_to_x()` like its a function. In this sense, creating a reactive expression is like to declaring an R function: nothing actually happens until you call it.

In the following snippet, the code contained in `up_to_x` (from the above snippet) is not executed until the line `print(up_to_x())` is reached, as this is the first time the result of `up_to_x` is actually requested. (Because of this property, we say that reactive expressions are _lazy_ as opposed to _eager_.)

```{r}
observe({
  print(up_to_x())
})

x(4)
```

This observer prints the sequence to the console whenever `up_to_x` changes (i.e. whenever `input$x` changes, because `up_to_x` reads `input$x`).

Just like with reading reactive values, reactive expressions are only readable by reactivity-aware consumers, and for the same reason: because `up_to_x()` is more than just "Can you calculate the current value of `up_to_x`?"; instead, it's "Can you calculate the current value of `up_to_x`? _And also notify me if something about this sequence changes?_"

So far we've learned that reactive expressions are _reactive_: they know when the reactive values they've read have changed, and they alert their readers when their own value may have changed. They're also _lazy_: they contain code, but that code doesn't execute unless/until someone tries to actually retrieve the value of the reactive expression (by calling it like a function).

The final important property of reactive expressions is that they _cache_ their most recent value. If you're not familiar with the term "cache", it means keeping a previously retrieved (or in this case, calculated) result in hand so that it can be used to satisfy future requests.

The first time a reactive expression is called, it will execute its code body, and depending on what that code does, it might take a significant amount of time. But when the calculation is complete, the resulting value will be both returned to the caller _and_ remembered by the reactive expression. Subsequent calls to the reactive expression take essentially no time at all, as the saved value can be returned instantly. If a reactive expression depends on reactive values or expressions, then any changes to those will cause the cached value to be discarded. When that happens, the next call to the reactive expression will again cause an actual calculation, whose result will then be saved for subsequent calls.

These particular properties--laziness, caching, reactivity, and lack of side effects--combine to give us an elegant and versatile building block for reactive programming.

### Outputs

You may wonder how Shiny outputs fit into this picture. By outputs, I'm referring to code like this:

```{r eval=FALSE}
output$text <- renderText({
  paste(up_to_x(), collapse = ", ")
})
```

Is this an observer or a reactive expression? It looks like a reactive expression because we're doing something with the result of `renderText()`, but as you've seen previously, `output` is write-only: you can't retrieve the value.

The answer is neither, per se. Reactive expressions and observers (and reactive values) are _primitives_ of reactive programming, meaning, they are fundamental building blocks. Outputs, on the other hand, are a feature of Shiny that is built on top of those reactive primitives. The details of how they are implemented are not that important, but it is important to know their characteristics.

Most importantly, outputs are reactive consumers. Output code is allowed to read reactive values like `input$x` or reactive expressions like `up_to_x()`, and the output will know when those reactive dependencies change.

Whereas observers execute eagerly and reactive expressions execute lazily, outputs are somewhere in between. When an output's corresponding UI element is visible in the browser, outputs execute eagerly; that is, once at startup, and once anytime their relevant inputs or reactive expressions change. However, if their UI element becomes hidden (e.g. it is located on a `tabPanel` that is not active, or `removeUI` is called to actively remove it from the page) then Shiny will automatically suspend (pause) that output from reactively executing. (In rare cases, you may prefer to process even outputs that aren't hidden. You can use the `outputOptions()` function's `suspendWhenHidden` to opt out of the automatic suspension feature on an output-by-output basis.)

We also know that observers should be used for side effects (actions), and reactive expressions for their return values (calculations). Again, outputs are somewhere in between. Depending on the `renderXXX` function you use to wrap it, your render code block may need to return a value and/or perform a side effect. For example, `renderText` expects you to return a string, while `renderPrint` expects you to make calls to `print()`; and `renderPlot` expects you to either draw a plot to the active graphics device or return a plottable object (like a ggplot2 object).

Though outputs allow (and may even require) side effects, this doesn't mean you should include just any side effects in your output code. Shiny assumes that the whole code block of an output exists only in service of populating that output. If your output code block contains logic whose side effects are important for reasons apart from the actual output, you should extract that logic into a separate observer. That way, you can be confident it will execute regardless of whether the output is visible or not, now or in the future.

