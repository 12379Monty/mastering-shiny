# Uploads and downloads {#action-transfer}

```{r, include = FALSE}
source("common.R")
```

Transferring files to and from the user is a common feature of apps. This is most commonly used to upload or download data, or to download a report generated from features of the app. This chapter shows you how to combine UI and server components make it easy for your users to get data to and from your app. 

```{r setup}
library(shiny)
```

## Upload

Upload a file is straightforward on the UI side: you just need to call `fileInput(id, label)`. It also has `multiple` and `accept` arguments that I'll discuss below. You can customise the appearance with `width`, `buttonLabel` and `placeholder` arguments, which you can learn more about in `?fileInput`.

Most of the complication arises on the server side because `input$file` returns a data frame with four columns:

* `name`: name of the file.

* `size`: file size, in bytes. By default the file size is capped at 5 MB. 
   If you want to increase this set `options(shiny.maxRequestSize)` to number 
   of bytes.

* `type`: the "mime type" of the file.

* `datapath`: the path to where the path has been uploaded to the server.
  Temporary directory. Made up name (number). This is a transient path; if the 
  user uploads more files it will go away.

This is a little more complicated than most other inputs which return single values. But you work with data frames in R a bunch so it shouldn't be too bad. I think the easiest way to get to grips with this input is to make a simple app that you can experiment with. Note the use of `multiple = TRUE` to allow the user to upload multiple files; this is the most complicated case.

```{r}
ui <- fluidPage(
  fileInput("upload", NULL, multiple = TRUE),
  tableOutput("files")
)
server <- function(input, output, session) {
  output$files <- renderTable(input$upload)
}
```

In most real cases you'll read in the user supplied data. There are two techniques to be aware of:

* When the page is initialised `input$file` is `NULL`, so we don't want to 
  do anything until the user has uploaded a file. Using `req(input$file)` 
  will wait until upload.
  
* `accept` argument allows you to limit the possible inputs. Easiest way is to
  use file extensions (you can also specify using mime types, as described in 
  the documentation). However, this is only a hint to the browser and is 
  not necessarily enforced. This means that you should also check the
  extension[^extensions] in the server function with `validate()`. 

[^extensions]: Note that the browser defintion of an extension is different to the definiton used by the browser - the browser uses `.csv` where `file_ext()` returns `.csv`.

```{r}
ui <- fluidPage(
  fileInput("file", NULL, accept = ".csv"),
  tableOutput("description")
)

server <- function(input, output, session) {
  data <- reactive({
    req(input$file)
    ext <- tools::file_ext(input$file$filename)
    validate(need(ext == "csv", "Please upload a CSV file"))
    
    vroom::vroom(input$file$datapath, delim = ",")
  })
  
  output$description <- renderTable({
    data()
  })
}
```

Note that if `multiple = FALSE` (the default), then `input$file` will be a single row data frame, and indexing into it with `$` will return a vector of length 1 --- there's no need to use `[1]`. 

## Download

Downloading a file is a little more complicated as you need a specific component in the server function that works a little differently to the other render functions.

* In UI, use `downloadButton(id)` or `downloadLink(id)` to give the user
  something to initiate to download a file. (There are other arguments, but 
  you'll hardly ever need them; see `?downloadButton` for the details.)
  
* In server, use `output$id <- downloadHandler()` to respond to the user and 
  send them a file.

`downloadHandler()` is a little different to other outputs because it requires two functions: one that determines the file name of the output, and the other that creates a file at a specified path. The following app shows off the basics by creating an app that lets you download any dataset in the datasets package as a csv file.

```{r}
ui <- fluidPage(
  selectInput("dataset", "Pick a dataset", ls("package:datasets")),
  downloadButton("download")
)
server <- function(input, output, session) {
  data <- reactive({
    get(input$dataset, "package:datasets")
  })
    
  output$download <- downloadHandler(
    filename = function() {
      paste0(input$dataset, ".csv")
    },
    content = function(file) {
      write.csv(data(), file)
    }
  )
}
```

Note the two important arguments to `downloadHandler()`:

*   `filename` should be a function with no arguments that returns a single 
    string giving the name of the file. This is the string that will appear in
    the download dialog box. I recommend avoiding special characters.
  
    If the file name is fixed, you can skip the function and just set it to
    a string.

*   `content` should be a function with a single argument that tells you where
    to save the file. The return argument of this function is ignored; it's 
    called purely for its side-effect of creating a file at the given path.

### Parametermised RMarkdown reports

Another common use of file downloads is to prepare a report that summarises the result of interactive exploration in the Shiny app. One powerful way to generate such a report is with a parameterised RMarkdown document,  <https://bookdown.org/yihui/rmarkdown/parameterized-reports.html>. A parameterised RMarkdown file has special YAML metadata:

```yaml
title: My Document
output: html_document
params:
  year: 2018
  region: Europe
  printcode: TRUE
  data: file.csv
```

And inside the document you can refer to those values with `params$year`, `params$region` etc. What makes this technique powerful is you can also set the parameters using code, by calling `rmarkdown::render()` with the `params` argument. This makes it possible to generate a range of RMarkdown reports from a single app.

Here's a simple example taken from <https://shiny.rstudio.com/articles/generating-reports.html>, which describes this technique in more detail.

```{r}
ui <- fluidPage(
  sliderInput("n", "Number of points", 1, 100, 50),
  downloadButton("report", "Generate report")
)

server <- function(input, output, session) {
  output$report <- downloadHandler(
    filename = "report.html",
    content = function(file) {
      params <- list(n = input$n)

      rmarkdown::render("report.Rmd", 
        output_file = file,
        params = params,
        envir = new.env(parent = globalenv())
      )
    }
  )
}
```

If you want to produce other output formats, just change the output format in the `.Rmd`, and make sure to update the extension.

There are a few other tricks worth knowing about:

*   If the report takes some time to generate, use one of the techniques from
    Chapter \@ref(action-feedback) to let the user know that your app is 
    working.

*   Often, when deploying the app, you can't write to the working directory,
    which RMarkdown will attempt to do. You can work around this by copying
    the report to a temporary directory:

    ```{r}
    report_path <- tempfile(fileext = ".Rmd")
    file.copy("report.Rmd", report_path, overwrite = TRUE)
    ```

    Then replaaing `"report.Rmd"` in the call to `rmarkdown::render()` with
    `report_path`.

*   By default, RMarkdown will render the report in the current process, which
    means that it will inherit many settings from the Shiny app (like loaded 
    packages, options, etc). For greater robustness, I recommend running in
    fresh R session by using the callr package. 
    
    ```{r, eval = FALSE}
    render_report <- function(input, output, params) {
      rmarkdown::render(input,
        output_file = output,
        params = params,
        envir = new.env(parent = globalenv())
      )
    }
    
    server <- function(input, output) {
      output$report <- downloadHandler(
        filename = "report.html",
        content = function(file) {
          params <- list(n = input$slider)
          callr::r(
            render_report,
            list(input = report_path, output = file, params = params)
          )
        }
      )
    }
    ```

You can see all these pieces put together in `rmarkdown-report/`.

Later, in Chapter XYZ, we'll come back to generating a complete report of all the code that your app has executed. 

## Case study

We'll put all the pieces together in a small case study where we upload a file (with user supplied separator), preview it, perform some optional transformations using the [janitor package](http://sfirke.github.io/janitor), by Sam Firke, and then let the user download it as a tsv (tab separated files are generally slightly better than csv because they're the same in Europe, and less likely to need quoting). We'll use vroom to read the data because it's fast.

```{r}
ui <- fluidPage(
  fileInput("file", "Data file to upload"),
  textInput("delim", "Delimiter (leave blank to guess)", ""),
  numericInput("skip", "Rows to skip", 0, min = 0),
  tableOutput("preview1"),
  checkboxInput("snake", "Rename columns to snake case?"),
  checkboxInput("constant", "Remove constant columns?"),
  checkboxInput("empty", "Remove empty cols?"),
  tableOutput("preview2"),
  downloadButton("download")
)
server <- function(input, output, session) {
  raw <- reactive({
    req(input$file)
    delim <- if (input$delim == "") NULL else input$delim
    vroom::vroom(input$file$datapath, delim = delim, skip = input$skip)
  })
  
  tidied <- reactive({
    out <- raw()
    if (input$snake) {
      names(out) <- janitor::make_clean_names(names(out))
    }
    if (input$empty) {
      out <- janitor::remove_empty(out, "cols")
    }
    if (input$constant) {
      out <- janitor::remove_constant(out)
    }
    
    out
  })
  
  output$preview1 <- renderTable(raw())
  output$preview2 <- renderTable(tidied())
  output$download <- downloadHandler(
    filename = function() {
      paste0(tools::file_path_sans_ext(input$file$name), ".tsv")
    },
    content = function(file) {
      vroom::vroom_write(tidied(), file)
    }
  )
}
```

